[ { "title": "[프로그래머스] 2023 KAKAO BLIND RECRUITMENT - 개인정보 수집 유효기간", "url": "/posts/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A41/", "categories": "Coding Test, Problem-Solving", "tags": "java", "date": "2025-10-01 02:30:00 +0900", "snippet": "0️⃣ 문제 링크 프로그래머스 SW개발자를 위한 평가, 교육의 Total Solution을 제공하는 개발자 성장을 위한 베이스캠프 school.programmers.co.kr 1️⃣ 문제 설명오늘 날짜(today), 약관별 유효기간(terms) 그리고 개인정보 수집일(privacies)이 주어진다.각 개인정보가 오늘 날짜 기준으로 유효기간이 만료되었는지 판별하여 파기해야 할 개인정보 번호를 오름차순으로 반환하는 문제이다. 날짜 : “YYYY.MM.DD” 형식의 문자열 파기 기준 : 수집일자 + 약관기간 ≤ 오늘 날짜2️⃣ 문제 접근 방식 날짜 문자열을 정수 배열로 변환 “YYYY.MM.DD” → [YYYY, MM, DD] 별도 함수 changeFormat()으로 분리 약관 정보를 HashMap으로 저장 각 약관의 종류에 따라 유효 개월 수를 바로 조회할 수 있도록 Map&lt;String, Integer&gt; 사용 각 개인정보에 대해 만료 여부 판단 수집일자에 약관 개월 수를 더해 만료일 계산 달 수가 12를 넘을 경우 → 연도 계산 처리 오늘 날짜(tDate)와 비교하여 파기 대상이면 결과 리스트(ans)에 추가 시간 복잡도 : O(N) → (N = privacies 길이) 각 개인정보를 한 번씩만 검사공간 복잡도 : O(T + N) → 약관 저장용 Map + 개인정보 검사 리스트3️⃣ 전체 코드import java.util.*;class Solution { public int[] solution(String today, String[] terms, String[] privacies) { // 오늘 날짜를 [YYYY, MM, DD] 형태로 변환 int[] tDate = changeFormat(today); // 약관 종류별 유효기간(개월) 저장 Map&lt;String, Integer&gt; term = new HashMap&lt;&gt;(); for (String str : terms) { String[] s = str.split(\" \"); term.put(s[0], Integer.parseInt(s[1])); } ArrayList&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); // 각 개인정보의 만료 여부 검사 for (int i = 0; i &lt; privacies.length; i++) { String[] s = privacies[i].split(\" \"); int[] pDate = changeFormat(s[0]); // 약관 기간(개월) 더하기 int mon = pDate[1] + term.get(s[1]); // 달이 12를 초과할 경우 연도 보정 if (mon &gt; 12) { if (mon % 12 == 0) { pDate[0] += mon / 12 - 1; mon = 12; } else { pDate[0] += mon / 12; mon %= 12; } } pDate[1] = mon; // 오늘 날짜와 만료일 비교 if (tDate[0] &gt; pDate[0]) { ans.add(i+1); continue; } else if (tDate[0] == pDate[0]) { if (tDate[1] &gt; pDate[1]) { ans.add(i+1); continue; } else if (tDate[1] == pDate[1]) { if (tDate[2] &gt;= pDate[2]) { ans.add(i+1); continue; } } } } // ArrayList -&gt; int[] 변환 int[] answer = new int[ans.size()]; for (int i = 0; i &lt; ans.size(); i++) { answer[i] = ans.get(i); } return answer; } // 날짜 포맷 변환 함수 static int[] changeFormat(String date) { String[] str = date.split(\"\\\\.\"); // 정규식: '.'은 메타문자이므로 '\\\\.'로 이스케이프 필요 int[] res = new int[3]; for (int i = 0; i &lt; 3 ; i++) { res[i] = Integer.parseInt(str[i]); } return res; }}4️⃣ 다른 풀이 날짜를 총 일수로 환산해서 비교하면 간단 예를 들어 “2022.05.19” → 20221228 + 5*28 + 19 이런 식으로 변환하면, 같은 기준에서 그냥 단순 비교 가능import java.util.*;class Solution { public int[] solution(String today, String[] terms, String[] privacies) { int tDate = toDays(today); // 약관 기간 저장 Map&lt;String, Integer&gt; term = new HashMap&lt;&gt;(); for (String str : terms) { String[] s = str.split(\" \"); term.put(s[0], Integer.parseInt(s[1])); } ArrayList&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; privacies.length; i++) { String[] s = privacies[i].split(\" \"); int start = toDays(s[0]); int expire = start + term.get(s[1]) * 28; // 한 달 = 28일 기준 if (expire &lt;= tDate) ans.add(i + 1); } return ans.stream().mapToInt(Integer::intValue).toArray(); } // 날짜를 \"YYYY.MM.DD\" → 총 일수로 변환 static int toDays(String date) { String[] str = date.split(\"\\\\.\"); int y = Integer.parseInt(str[0]); int m = Integer.parseInt(str[1]); int d = Integer.parseInt(str[2]); return (y * 12 * 28) + (m * 28) + d; }}5️⃣ 회고 및 배운점💡 오답 원인 날짜 split 시 date.split(\".\") 로 작성하여 정규식 오류 발생 (\".\"은 모든 문자를 의미함 → \"\\\\.\"로 수정) 달 계산 시 mon % 12 == 0 인 경우를 고려하지 않아 연도 계산 틀림 예: 2021.12 + 12개월 = 2022.12가 아닌 2023.00으로 처리되는 문제 💡 배운 점날짜 계산 문제는 단위 변환으로 단순화하는 게 가독성과 안정성 등 모든 면에서 편리하다는 것을 깨닫게 되었다.자바 문자열 안에서의 정규식을 표현하는 방식에 대해 알 수 있었던 기회였다.항상 ArrayList&lt;Integer&gt; → int[] 변환에 대해 고민을 하는데, 가장 간단한 방법(반복문 이용)이 있다는 것을 잊지 말아야겠다." }, { "title": "[블로그 설정] Jekyll에서 URL 미리보기 적용하기", "url": "/posts/%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%81%ED%81%AC%ED%94%84%EB%A6%AC%EB%B7%B0-%EC%84%A4%EC%A0%95/", "categories": "etc, Blog", "tags": "blog", "date": "2025-09-30 02:30:00 +0900", "snippet": "URL 미리보기(Link preview)는 단순히 링크 텍스트를 나열하는 대신, 링크된 페이지의 제목, 설명, 썸네일 이미지를 시각적으로 보여주는 것이다. 그러나 Jekyll로 만든 블로그에서는 URL 미리보기 기능이 없어서 이를 직접 적용해야 한다. 아래는 jekyll-linkpreview 플러그인을 활용해 이를 구현하고, Chirpy 테마 사용 시 발생할 수 있는 목차(TOC) 충돌 문제를 해결하는 방법이다.1️⃣ jekyll-linkpreview 설치 Gemfile에 추가 : 프로젝트 루트 디렉토리의 Gemfile에 다음 라인을 추가한다. group :jekyll_plugins do gem \"jekyll-linkpreview\"end _config.yml에 플러그인 등록 : 프로젝트 루트 디렉토리의 _config.yml 파일에 jekyll-linkpreview를 plugins 목록에 추가한다. plugins: - jekyll-linkpreview 번들 설치 : 터미널에서 아래 명령어를 실행하여 플러그인 설치하기. bundle install _cache 폴더 추가 : 프로젝트 루트 디렉토리 바로 아래에 _cache 폴더를 추가한다. css 파일 추가 : 참고한 블로그에서는 새로운 파일로 추가했지만, 적용이 되지 않아 기존에 있던 파일에 아래 코드 추가하기. (파일 위치 : assets/css/style.scss) 기본 제공 CSS 파일 /* append your custom style below */ .jekyll-linkpreview-wrapper { display: flex; max-width: 100%; max-height: 160px; border: 1px solid #eee; /* 변경된 테두리 */ border-radius: 8px; /* 둥근 모서리 */ position: relative; overflow: hidden; /* 이미지 둥근 모서리 처리 */ } .jekyll-linkpreview-wrapper-inner { padding: 15px; display: flex; width: 100%; align-items: start; /* 이미지와 텍스트 영역 세로 중앙 정렬 */ } .jekyll-linkpreview-content { display: flex; flex-direction: column; flex-grow: 1; margin-right: 16px; /* 조정된 간격 */ } .jekyll-linkpreview-body { display: flex; flex-direction: column; justify-content: space-between; height: 100%; } .jekyll-linkpreview-title { font-size: 16px; /* 조정된 제목 크기 */ margin: 0 0 4px; /* 조정된 간격 */ line-height: 1.4; font-weight: bold; /* 제목 굵게 */ } .jekyll-linkpreview-description { line-height: 1.4; font-size: 13px; margin-bottom: 8px; /* 조정된 간격 */ color: #888; /* 설명 색상 변경 */ } .jekyll-linkpreview-footer { font-size: 12px; text-align: left; color: #555; } .jekyll-linkpreview-image { flex-shrink: 0; height: 160px; /* 이미지 높이 조정 */ aspect-ratio: 16 / 10; overflow: hidden; box-sizing: border-box; background-size: cover; background-position: center; } 2️⃣ jekyll-linkpreview 사용 방법설치가 완료되면, Liquid 문법을 사용해 작성하면 된다.{% linkpreview \"https://www.google.com\" %}이렇게 하면 지정된 URL에 대한 미리보기가 자동으로 생성되어 아래와 같이 표시된다. GitHub · Build and ship software on a single, collaborative platform Join the world's most widely adopted, AI-powered developer platform where millions of developers, businesses, and the largest open source community build software that advances humanity. github.com 3️⃣ Chirpy 테마의 목차(TOC) 충돌 문제Chirpy 테마를 사용하는 경우, jekyll-linkpreview의 기본 출력 HTML이 목차(Table of Contents, TOC) 생성기와 충돌하여 의도치 않은 항목이 목차에 포함될 수 있다. 이는 jekyll-linkpreview가 기본적으로 링크 제목을 &lt;h2&gt; 태그로 렌더링하고, Chirpy의 경우 목차는 &lt;h2&gt; ~ &lt;h3&gt; 태그를 기준으로 생성되기 때문이다.해결 방법jekyll-linkpreview의 경우, 커스텀 템플릿을 지원하기 때문에 &lt;h2&gt; 태그를 제거할 수 있다. _includes 폴더에 linkpreview.html 파일을 생성해 아래 코드를 추가한다. 해당 파일의 경우 지킬 문법을 사용하기 때문에, Liquid 문법을 사용하여 작성해야 한다.&lt;div class=\"jekyll-linkpreview-wrapper\"&gt; &lt;div class=\"jekyll-linkpreview-wrapper-inner\"&gt; &lt;div class=\"jekyll-linkpreview-content\"&gt; &lt;div class=\"jekyll-linkpreview-body\"&gt; &lt;div class=\"jekyll-linkpreview-title\"&gt; &lt;a href=\"{{ url }}\" target=\"_blank\"&gt;{{ title }}&lt;/a&gt; &lt;/div&gt; {% if description %} &lt;div class=\"jekyll-linkpreview-description\"&gt;{{ description }}&lt;/div&gt; {% endif %} &lt;div class=\"jekyll-linkpreview-footer\"&gt; &lt;a href=\"{{ url }}\" target=\"_blank\"&gt;{{ domain }}&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; {% if image %} &lt;div class=\"jekyll-linkpreview-image\" style=\"background-image: url('{{ image }}');\"&gt;&lt;/div&gt; {% endif %}&lt;/div&gt; GitHub Actions 에러 루비 버전(2.7.8)이 너무 낮아서, 설치되지 않아 오류 발생 Ruby 3.x로 버전을 올려서 해결 pages-deploy.yml 파일 안에서 루비 버전을 2.7 → 3.1로 변경 (파일 위치 : .github/workflows/pages-deploy.yml) - name: Setup Ruby uses: ruby/setup-ruby@v1 with: ruby-version: 3.1 # 버전 변경 bundler-cache: true 4️⃣ jekyll-linkpreview 주소아래에서 상세한 설명을 확인할 수 있다. GitHub - ysk24ok/jekyll-linkpreview: Jekyll plugin to generate link preview Jekyll plugin to generate link preview. Contribute to ysk24ok/jekyll-linkpreview development by creating an account on GitHub. github.com " }, { "title": "[코딩테스트] Java 정리 - 3", "url": "/posts/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%9E%90%EB%B0%94-%EC%A0%95%EB%A6%AC3/", "categories": "Coding Test, Study", "tags": "java", "date": "2025-08-14 02:30:00 +0900", "snippet": "코딩테스트에서의 클래스와 메서드에 대해 간단히 정리했습니다.1️⃣ 클래스와 객체클래스 정의와 필드/생성자/메서드// 파일: Main.java (보통 public class Main, public 클래스는 하나만 가능)class Point { // (public 생략 → 같은 파일에서만 사용 가능) int x; // 필드(인스턴스 변수) int y; static int val = 10; // 클래스(static) 변수 // 기본 생성자 (생략 가능) Point() {} // 생성자 오버로딩 Point(int x, int y) { this.x = x; this.y = y; } // 인스턴스 메서드 (객체 상태 사용) int manhattan() { return Math.abs(x) + Math.abs(y); } // static 메서드 (객체 상태 없이 동작) static int distanceSquared(Point a, Point b) { int dx = a.x - b.x, dy = a.y - b.y; return dx*dx + dy*dy; }}객체 생성/사용Point p = new Point(3, -4); // 생성int m = p.manhattan(); // 인스턴스 메서드 호출int d2 = Point.distanceSquared(p, new Point(0, 0)); // static 메서드는 클래스명.메서드2️⃣ 함수(메서드)메서드 정의반환타입 메서드이름(매개변수들) { // 로직 return 값; // void면 생략}static int gcd(int a, int b) { // 인스턴스 변수를 사용하지 않음 → static 적합 while (b != 0) { int t = a % b; a = b; b = t; } return a;}메서드 오버로딩static int sum(int a, int b) { return a + b; }static long sum(long a, long b) { return a + b; } // 같은 이름, 파라미터 다름가변인자static int sumAll(int... nums) { int s = 0; for (int v : nums) s += v; return s;}3️⃣ static vs non-static 구분 static (정적) non-static (인스턴스) 소속 클래스에 소속 (전체 공유) 객체(인스턴스)에 소속 (객체마다 별도) 수명 클래스가 메모리에 올라갈 때 → 종료/클래스 언로드 시까지 new 할 때마다 생성 → 인스턴스가 소멸할 때 (가비지 컬렉터가 회수) 메모리 메소드(Static) 영역 힙 영역 접근 방식 클래스명.필드/메서드() 참조변수.필드/메서드() (객체 필요) 인스턴스 멤버 접근 불가 (this 없음, 인스턴트보다 static이 먼저 생성됨) 가능 쓰임새 유틸성 함수, 전역 상수/공유 상태, 캐시 객체 상태 기반 동작, 다형성/캡슐화 오버라이딩 불가(정확히는 숨김/hiding) 가능 (다형성) 스레드 안전 공유하므로 주의 필요 객체별로 분리되어 상대적으로 안전 4️⃣ Main과 보조 클래스 배치자바 규칙: 한 파일엔 public 최상위 클래스 1개만 허용 (파일명과 동일) 코테에선 보통 public class Main만 public이고, 그 외 클래스는 두 방법 모두 가능(A) 최상위(Top-Level) 비공개 클래스로 Main 바깥에 배치 장점 : 깔끔, 일반 자바와 동일한 패턴 주의 : public 붙이면 컴파일 에러public class Main { public static void main(String[] args) {}}class Node { // public 없음 int v, w; Node(int v, int w){ this.v=v; this.w=w; } }(B) Main 안에 중첩 클래스로 배치 static class는 바깥 인스턴스 없이 독립적이라 사용 간단 non-static inner class는 new Main().new Node()처럼 외부 인스턴스 필요 → 비추천public class Main { static class Node { // 권장 int v, w; Node(int v, int w){ this.v=v; this.w=w; } } // non-static class Node { ... } // 비권장: 바깥 Main 인스턴스가 필요해져 번거로움 public static void main(String[] args) { Node n = new Node(1, 3); // static 중첩 클래스는 바로 생성 가능 }}5️⃣ 코딩테스트에선? 상태를 안 쓰는 함수(예: 파싱, 수학, 그래프 유틸) → static 메서드가 간단/빠름 공유 상수/공통 배열(예: 방향 배열) → static final 상수로 선언 문제 모델링용 구조체/노드 → 보통 static 중첩 클래스로 정의 단, 전역 static 가변 상태는 테스트 케이스 반복 시 초기화 누락 버그 주의 (init() 함수)지역 변수 사용import java.io.*;import java.util.*;public class Main { // ✅ 전역 상수/배열 (예: 방향 벡터) static final int[] DX = {-1, 1, 0, 0}; static final int[] DY = {0, 0, -1, 1}; // ✅ 자료구조용 static class static class Node implements Comparable&lt;Node&gt; { int x, y, dist; Node(int x, int y, int dist) { this.x = x; this.y = y; this.dist = dist; } @Override public int compareTo(Node o) { return Integer.compare(this.dist, o.dist); // 우선순위 큐용 } } // ✅ 유틸 함수 예시 static int gcd(int a, int b) { while (b != 0) { int t = a % b; a = b; b = t; } return a; } static int lcm(int a, int b) { return a / gcd(a, b) * b; } static boolean inRange(int x, int y, int n, int m) { return (0 &lt;= x &amp;&amp; x &lt; n &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; m); } // ✅ 문제 풀이 함수 (호출 시 지역 변수 자동 초기화) static void solve(BufferedReader br, StringBuilder sb) throws Exception { StringTokenizer st = new StringTokenizer(br.readLine()); int n = Integer.parseInt(st.nextToken()); int m = Integer.parseInt(st.nextToken()); // 2차원 배열 입력 int[][] grid = new int[n][m]; for (int i = 0; i &lt; n; i++) { st = new StringTokenizer(br.readLine()); for (int j = 0; j &lt; m; j++) { grid[i][j] = Integer.parseInt(st.nextToken()); } } // BFS 예시 boolean[][] visited = new boolean[n][m]; Queue&lt;int[]&gt; q = new ArrayDeque&lt;&gt;(); q.offer(new int[]{0, 0}); visited[0][0] = true; while (!q.isEmpty()) { int[] cur = q.poll(); int x = cur[0], y = cur[1]; for (int d = 0; d &lt; 4; d++) { int nx = x + DX[d], ny = y + DY[d]; if (inRange(nx, ny, n, m) &amp;&amp; !visited[nx][ny] &amp;&amp; grid[nx][ny] == 0) { visited[nx][ny] = true; q.offer(new int[]{nx, ny}); } } } sb.append(\"탐색 완료\\n\"); } // ✅ main: 입출력 전담 public static void main(String[] args) throws Exception { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); int T = 1; // 여러 테스트케이스 지원 시: T = Integer.parseInt(br.readLine()); for (int t = 0; t &lt; T; t++) { solve(br, sb); } System.out.print(sb); }}전역 변수 사용 (init 함수)import java.io.*;import java.util.*;public class Main { // 전역 상수 static final int[] DX = {-1, 1, 0, 0}; static final int[] DY = {0, 0, -1, 1}; // 전역 변수 (테스트케이스마다 초기화 필요할 때 사용) static int n, m; static int[][] grid; static boolean[][] visited; // ✅ init 함수 static void init(int n, int m) { // 전역 변수 초기화 Main.n = n; Main.m = m; grid = new int[n][m]; visited = new boolean[n][m]; } // ✅ 유틸 함수 static boolean inRange(int x, int y) { return (0 &lt;= x &amp;&amp; x &lt; n &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; m); } // ✅ 문제 풀이 함수 static void solve(BufferedReader br, StringBuilder sb) throws Exception { StringTokenizer st = new StringTokenizer(br.readLine()); n = Integer.parseInt(st.nextToken()); m = Integer.parseInt(st.nextToken()); // init으로 초기화 init(n, m); // grid 입력 for (int i = 0; i &lt; n; i++) { st = new StringTokenizer(br.readLine()); for (int j = 0; j &lt; m; j++) { grid[i][j] = Integer.parseInt(st.nextToken()); } } // BFS 예시 Queue&lt;int[]&gt; q = new ArrayDeque&lt;&gt;(); q.offer(new int[]{0, 0}); visited[0][0] = true; while (!q.isEmpty()) { int[] cur = q.poll(); int x = cur[0], y = cur[1]; for (int d = 0; d &lt; 4; d++) { int nx = x + DX[d], ny = y + DY[d]; if (inRange(nx, ny) &amp;&amp; !visited[nx][ny] &amp;&amp; grid[nx][ny] == 0) { visited[nx][ny] = true; q.offer(new int[]{nx, ny}); } } } sb.append(\"탐색 완료\\n\"); } // ✅ main 함수 public static void main(String[] args) throws Exception { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); int T = 1; // 여러 테스트 케이스 // T = Integer.parseInt(br.readLine()); for (int t = 0; t &lt; T; t++) { solve(br, sb); } System.out.print(sb); }}" }, { "title": "[Java] 집합 연산 정리 (합집합/교집합/차집합/부분집합)", "url": "/posts/%EC%9E%90%EB%B0%94-%EA%B3%B5%EB%B6%808/", "categories": "Coding Test, Study", "tags": "java", "date": "2025-08-13 02:30:00 +0900", "snippet": "집합 연산에 대해 정리했습니다.1️⃣ 집합 연산 메서드 연산 메서드 방법 시간복잡도 합집합 (Union) addAll() set1.addAll(set2) O(n+m) 교집합 (Intersection) retainAll() set1.retainAll(set2) O(min(n, m)) 차집합 (Difference) removeAll() set1.removeAll(set2) O(n) 부분집합 (Subset) containsAll() set1.containsAll(set2) O(n) 메서드 사용 자료구조 위 메서드들은 Collection 인터페이스에서 제공하는 메서드로 List, Set 모두 사용 가능 그러나 List에서는 중복과 순서 때문에 결과가 다를 수 있음2️⃣ 코드 예제import java.util.*;public class Main { public static void main(String[] args) { Set&lt;Integer&gt; set1 = new HashSet&lt;&gt;(Arrays.asList(1, 2, 3, 4, 5)); Set&lt;Integer&gt; set2 = new HashSet&lt;&gt;(Arrays.asList(3, 4, 5, 6, 7)); // 합집합 Set&lt;Integer&gt; union = new HashSet&lt;&gt;(set1); union.addAll(set2); // set1 ∪ set2 System.out.println(\"합집합: \" + union); // [1, 2, 3, 4, 5, 6, 7] // 교집합 Set&lt;Integer&gt; intersection = new HashSet&lt;&gt;(set1); intersection.retainAll(set2); // set1 ∩ set2 System.out.println(\"교집합: \" + intersection); // [3, 4, 5] // 차집합 Set&lt;Integer&gt; difference = new HashSet&lt;&gt;(set1); difference.removeAll(set2); // set1 - set2 System.out.println(\"차집합: \" + difference); // [1, 2] // 부분집합 boolean isSubset = set1.containsAll(intersection); // intersection ⊆ set1 System.out.println(\"intersection은 set1의 부분집합인가? \" + isSubset); // true }}" }, { "title": "[개발환경] 터미널에서 Alias 단축어 설정 방법", "url": "/posts/%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD-%ED%84%B0%EB%AF%B8%EB%84%90/", "categories": "etc, DevEnv", "tags": "terminal", "date": "2025-08-12 02:30:00 +0900", "snippet": "터미널에서 GitBash를 이용하는데 매번 명령어로 폴더 위치 이동하고, 서버 실행하는게 너무너무 불편해서 alias에 대해 찾아보고 정리하게 되었습니다.1️⃣ alias란?터미널에서 자주 사용하는 길거나 복잡한 명령어를 짧고 기억하기 쉬운 단어로 대체할 수 있도록 해주는 ‘별명’ 또는 ‘단축어’ 기능입니다. alias를 사용하면 명령어 입력 시간을 줄이고 오타 발생 가능성을 낮출 수 있어 작업 효율성을 크게 높일 수 있습니다.예시: ls -alF (숨김 파일 포함하여 상세 목록, 파일 유형 표시) 명령어를 ll이라는 짧은 단축어로 사용 가능2️⃣ 임시 alias 설정 (재부팅 시 초기화됨)터미널 세션이 종료되거나 컴퓨터를 재부팅하면 사라지는 임시 Alias를 설정하는 방법입니다. 테스트용으로 사용하거나 일회성으로 사용할 때 유용합니다.# 등록되어 있는 모든 별칭 확인alias# 명령어 등록 : alias 단축어이름='원래_명령어'alias ll='ls -alF'# 명령어 해제 : unalias 단축어이름unalias ll3️⃣ 영구적인 alias 설정 (재부팅 후에도 유지)Alias를 영구적으로 사용하려면 셸(Shell)의 설정 파일에 등록해야 합니다. 대부분의 리눅스 시스템에서 기본 셸은 Bash이며, 이 경우 ~/.bashrc 파일에 Alias를 추가합니다. Zsh을 사용한다면 ~/.zshrc 파일에 추가합니다. 파일이 없다면 새로 생성하면 됩니다. (환경 설정의 파일 이름은 셸마다 다를 수 있습니다.)설정 방법 사용하는 셸의 설정 파일을 vi 또는 nano 명령어를 통해 텍스트 편집기로 엽니다. (Bash의 경우 ~/.bashrc) 파일의 아무 곳에나 (보통 파일의 끝에 추가) 다음과 같은 형식으로 alias를 추가합니다. alias 단축어이름='원래_명령어' 파일을 저장하고 닫습니다. 변경사항을 즉시 적용하려면 다음 명령어를 실행합니다. (재부팅 시 자동 적용되지만 즉시 사용하려면 필요) source ~/.bashrc 편집기 사용 방법 1) vi 에디터 사용 vi는 강력하지만 초보자에게는 다소 어려울 수 있는 텍스트 에디터입니다. vi ~/.bashrc 파일이 열리면 i 키를 눌러 “INSERT” 모드로 전환합니다. 원하는 Alias를 추가합니다. (예: alias cls='clear') Esc 키를 눌러 명령 모드로 돌아갑니다. :wq를 입력하고 Enter 키를 눌러 저장하고 종료합니다. (저장하지 않고 종료하려면 :q! 입력) 2) nano 에디터 사용 nano는 사용하기 쉬운 텍스트 에디터입니다. nano ~/.bashrc 파일이 열리면 원하는 Alias를 추가합니다. (예: alias getup='cd ../..') Ctrl + O (저장)를 누른 후 Enter 키를 누릅니다. Ctrl + X (종료)를 눌러 에디터를 닫습니다. " }, { "title": "[Github] 깃허브 리드미 꾸미기", "url": "/posts/%EA%B9%83%ED%97%88%EB%B8%8C-%EA%BE%B8%EB%AF%B8%EA%B8%B0/", "categories": "etc, GitHub", "tags": "github", "date": "2025-08-11 02:30:00 +0900", "snippet": "GitHub에 처음 들어갔을 때 보이는 Profile인 Readme를 꾸미기위한 모든 것을 정리했습니다.리드미 파일에서는 html과 마크다운 문법을 모두 사용할 수 있습니다.0️⃣ 프로필 Readme용 Repository 생성 깃허브 아이디와 동일한 이름의 레포지토리 만들기 (✨special ✨ repository 생성 가능) Add README file 체크하기1️⃣ Header &amp; Footer헤더 이미지 적용 : https://github.com/kyechan99/capsule-render&lt;img src=\"https://capsule-render.vercel.app/api?type=모양&amp;color=색상코드&amp;height=높이&amp;section=header&amp;text=텍스트&amp;fontSize=텍스트크기\" /&gt;![header](https://capsule-render.vercel.app/api?type=wave&amp;color=auto&amp;height=300&amp;section=header&amp;text=capsule%20render&amp;fontSize=90)2️⃣ Badge뱃지 생성 : https://shields.io/로고 이미지 : https://simpleicons.org/만들어진 뱃지 : https://github.com/Envoy-VC/awesome-badges# 일반 뱃지 &lt;img src=\"https://img.shields.io/badge/텍스트-바탕색?style=스타일이름&amp;logo=로고이름&amp;logoColor=로고색\"/&gt;# 링크 연결되는 뱃지&lt;a href=\"링크\"&gt;&lt;img src=\"https://img.shields.io/badge/텍스트-바탕색?style=스타일이름&amp;logo=로고이름&amp;logoColor=로고색\"/&gt;&lt;/a&gt;![아무뱃지이름](https://img.shields.io/badge/내용-바탕색?style=스타일이름&amp;logo=로고이름&amp;logoColor=로고색)3️⃣ WidgetGithub 가장 많이 사용한 언어 / stats / 저장소 핀 : https://github.com/anuraghazra/github-readme-stats&lt;img src=\"https://github-readme-stats.vercel.app/api/top-langs/?username=깃허브아이디&amp;layout=compact&amp;theme=테마이름\"&gt;&lt;img src=\"https://github-readme-stats.vercel.app/api?username=본인아이디&amp;show_icons=true&amp;theme=테마이름\"&gt;&lt;img src=\"https://github-readme-stats.vercel.app/api/pin/?username=깃허브아이디&amp;repo=레포지토리이름&amp;theme=테마이름\"&gt;![Top-Langs](https://github-readme-stats.vercel.app/api/top-langs/?username=깃허브아이디&amp;layout=compact&amp;theme=테마이름)![GitHub-stats](https://github-readme-stats.vercel.app/api?username=깃허브아이디&amp;show_icons=true&amp;theme=테마이름)![Readme-Card](https://github-readme-stats.vercel.app/api/pin/?username=깃허브아이디&amp;repo=레포지토리이름&amp;theme=테마이름)4️⃣ 백준 티어백준 티어 프로필 : https://github.com/mazassumnida/mazassumnida[![Solved.ac-Profile](http://mazassumnida.wtf/api/generate_badge?boj=백준아이디)](https://solved.ac/백준아이디)5️⃣ 기타 사이트타이핑 애니메이션 : https://readme-typing-svg.demolab.com/demo/3D 잔디 적용 방법1 : https://h-owo-ld.tistory.com/2643D 잔디 적용 방법2 : https://soooom.tistory.com/436움직이는 이모지 : https://animated-fluent-emoji.vercel.app/리드미 이모지 입력 : https://gist.github.com/rxaviers/7360908그라데이션 색상 팔레트 : https://uigradients.com/#VeryBlue컬러 팔레트 : https://mybrandnewlogo.com/ko/color-palette-generator백준 solved.ac 잔디 추가 : https://github.com/mazassumnida/mazandiGithub 커밋 시간대 : https://github.com/techinpark/productive-boxGithub 방문자 수 : https://hits.seeyoufarm.com/Github Contribution 스트릭 : https://github.com/DenverCoder1/github-readme-streak-statsGithub Contribution 그래프 : https://github.com/ashutosh00710/github-readme-activity-graph" }, { "title": "[Java] String 클래스 메소드 총정리", "url": "/posts/%EC%9E%90%EB%B0%94-%EA%B3%B5%EB%B6%807/", "categories": "Coding Test, Study", "tags": "java", "date": "2025-08-08 02:40:00 +0900", "snippet": "String 클래스의 메소드에 대해 정리했습니다.1️⃣ 문자열 길이 및 접근 메소드 설명 예시 int length() 문자열 길이 반환 \"hello\".length() → 5 char charAt(int index) i번째 문자 반환 \"hello\".charAt(1) → 'e' String substring(int begin, int end) [a, b) 구간 추출 (end 없으면 끝까지) \"hello\".substring(1, 3) → \"el\" toCharArray() 문자열 → char[] 변환 \"abc\".toCharArray() 2️⃣ 문자열 비교 메소드 설명 예시 boolean equals(Object obj) 내용 비교 (대소문자 구분) \"abc\".equals(\"abc\") → true boolean equalsIgnoreCase(String str) 대소문자 무시 비교 \"ABC\".equalsIgnoreCase(\"abc\") → true int compareTo(String str) 사전순 비교 (0: 동일, &lt;0: 앞, &gt;0: 뒤) \"apple\".compareTo(\"banana\") → &lt; 0 3️⃣ 문자열 검색 메소드 설명 예시 boolean contains(CharSequence s) 특정 문자열 포함 여부 \"hello\".contains(\"he\") → true boolean startsWith(String prefix) 접두사 확인 \"hello\".startsWith(\"he\") → true boolean endsWith(String suffix) 접미사 확인 \"hello\".endsWith(\"lo\") → true int indexOf(String str) 처음 등장 위치 (없으면 -1) \"banana\".indexOf(\"na\") → 2 int lastIndexOf(String str) 마지막 등장 위치 (없으면 -1) \"banana\".lastIndexOf(\"na\") → 4 4️⃣ 문자열 변환 메소드 설명 예시 String replace(char old, char new) 특정 문자열 교체 \"hello\".replace(\"l\", \"x\") → \"hexxo\" String replaceAll(String regex, String replacement) 정규식 패턴 교체 \"a1b2\".replaceAll(\"[0-9]\", \"\") → \"ab\" String[] split(String regex) 구분자 기준 분리 \"a,b,c\".split(\",\") → [\"a\",\"b\",\"c\"] String trim() 앞뒤 공백 제거 \" hello \".trim() → \"hello\" String toUpperCase() 대문자로 변환 \"abc\".toUpperCase() → \"ABC\" String toLowerCase() 소문자로 변환 \"ABC\".toLowerCase() → \"abc\" String valueOf(Object obj) 기본형 → 문자열 String.valueOf(123) → \"123\" char[] toCharArray() 문자열 → char[] 변환 \"abc\".toCharArray() → ['a','b','c'] 5️⃣ 문자열 결합 방법 설명 예시 + 문자열 결합 (비효율적) \"a\" + \"b\" → \"ab\" String concat(String str)) 문자열 결합 \"a\".concat(\"b\") → \"ab\" String join(CharSequence delimiter, CharSequence... elements) 문자열 배열을 구분자로 합침 String.join(\"-\", \"a\", \"b\", \"c\") → “a-b-c” 6️⃣ 기본자료형 변환 변환 예시 문자열 → 숫자 Integer.parseInt(\"123\") → 123 char → 숫자 '5' - '0' → 5 숫자 → char (char)(5 + '0') → '5' " }, { "title": "[Java] String / StringBuffer / StringBuilder 차이", "url": "/posts/%EC%9E%90%EB%B0%94-%EA%B3%B5%EB%B6%806/", "categories": "Coding Test, Study", "tags": "java", "date": "2025-08-08 02:30:00 +0900", "snippet": "String, StringBuffer, StringBuilder의 차이에 대해 정리했습니다.1️⃣ String개념 문자열을 불변(Immutable) 객체로 관리특징 한 번 생성되면 값이 변경되지 않음 불변이므로 +, concat() 등으로 수정 시 새 객체를 생성 속도 느려짐과 메모리 낭비 가능성 있음 문자열 리터럴은 문자열 풀(String Pool)에 저장 → 동일 문자열 재사용 스레드 안전(thread-safe) → 불변이라 여러 스레드에서 동시에 사용해도 안전주요 메소드 length() : 문자열 길이 반환 charAt(int index) : 특정 위치 문자 반환 substring(int begin, int end) : 부분 문자열 반환 toUpperCase(), toLowerCase() : 대소문자 변환 equals(), compareTo() : 문자열 비교 trim(), replace(), split() 등사용 예시String s = \"Hello\";s = s + \" World\"; // 기존 s는 그대로, 새로운 객체 생성System.out.println(s); // \"Hello World\" JAVA에서 String을 불변으로 설정한 이유 캐싱, 보안, 동기화, 성능측면 이점을 얻기 위해 캐싱 : String pool에 각 리터럴 문자열의 하나만 저장하며 다시 사용하거나 캐싱에 이용가능하며 이로 인해 힙 공간을 절약할 수 있음 보안 : 데이터베이스 사용자 이름, 암호는 수신하기 위해 문자열로 전달되는데, 만일 번지수의 문자열 값이 변경이 가능하다면 해커가 참조 값을 변경하여 보안 문제 발생 가능 동기화 : 동시에 실행되는 여러 스레드에서 안정적이게 공유 가능 2️⃣ StringBuffer / StringBuilder개념 문자열을 가변(Mutable) 객체로 관리특징 문자열 수정 가능 문자열 변경 시 새로운 객체를 만들지 않고, 독립적인 공간인 버퍼 내부에서 수정 공간 낭비 없고, 연산 속도 빠름 문자열 조작(추가, 삭제, 변경)이 잦을 때 유리 동등 비교 시 String 객체로 변환 후 equals() 사용차이점 StringBuffer : 멀티 쓰레드 안전(thread-safe) → synchronized 적용 (성능은 약간 떨어짐) StringBuilder : 멀티 쓰레드 안전하지 않음 → synchronized 적용 X (동기화 오버헤드가 없어 성능 빠름) JAVA에서 synchronized 키워드 여러개의 스레드가 한 개의 자원에 접근할려고 할 때, 현재 데이터를 사용하고 있는 스레드를 제외하고 나머지 스레드들이 데이터에 접근할 수 없도록 막음 web이나 Socket과 같이 비동기 동작 많을 때, StringBuffer 사용하는 것이 안전주요 메소드 append(String str) : 문자열 추가 (다양한 자료형 가능 - 문자열로 자동 변환) insert(int offset, String str) : 특정 위치에 삽입 (두 번째 매개변수의 자료형은 다양함 - 문자열로 자동 변환) delete(int start, int end) : 부분 삭제 deleteCharAt(int index) : 지정된 위치의 문자 제거 replace(int start, int end, String str) : 부분 교체 setCharAt(int index, char ch) : 지정된 위치의 문자를 두 번째 매개변수로 변경 charAt(int index) : 지정된 위치에 있는 문자 반환 substring(int start), substring(int start, int end) : 지정된 범위 문자열 반환 reverse() : 문자열 뒤집기 length() : 문자열 길이 반환 setLength(int newLength) : 지정된 길이로 문자열 길이 변경 (빈공간은 널문자로 채움) capacity() : 버퍼크기 반환 toString() : StringBuffer를 String으로 변환사용 예시StringBuffer sb = new StringBuffer(\"Hello\");System.out.println(sb);System.out.println(sb.toString());System.out.println(sb.substring(2,4));System.out.println(sb.insert(2,\"추가\"));System.out.println(sb.delete(2,4));System.out.println(sb.append(\" World\"));System.out.println(sb.length());StringBuilder sb = new StringBuilder(\"Hello\");sb.append(\" World\");System.out.println(sb); // \"Hello World\"3️⃣ 전체 비교 정리 구분 String StringBuffer StringBuilder 불변성 불변 (Immutable) 가변 (Mutable) 가변 (Mutable) 스레드 안전성 안전 (불변이라서) 안전 (synchronized 적용) 안전하지 않음 성능 느림 (새 객체 생성) 빠름 (동기화 때문에 약간 느림) 가장 빠름 사용 시기 문자열 변경 거의 없음 멀티스레드 환경에서 문자열 조작 단일 스레드 환경에서 문자열 조작 주요 메소드 length(), substring(), equals() append(), insert(), delete() append(), insert(), delete() 참고 블로그 Inpa Dev - String/StringBuffer/StringBuilder 차이점 &amp; 성능 비교 " }, { "title": "[알고리즘] 플로이드 워셜(Floyd-Warshall)", "url": "/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C/", "categories": "Coding Test, Algorithm", "tags": "java, algorithm, floyd-warshall", "date": "2025-08-07 02:30:00 +0900", "snippet": "플로이드 워셜(Floyd-Warshall)에 대해 공부 후 정리하였습니다.1️⃣ 개념다이나믹 프로그래밍 기반의 최단 경로 알고리즘으로 그래프 내 모든 정점 쌍 (i, j) 사이의 최단 거리를 구함. 다익스트라가 한 정점에서 출발하는 최단 경로를 구하는 것과 달리, 플로이드-워셜은 전체 쌍을 고려한다. 음수 가중치 간선도 허용(단, 음수 사이클은 허용하지 않음).2️⃣ 특징 모든 정점 쌍 최단 거리 계산 가능 음수 가중치 허용(음수 사이클 존재 시 경로 불가능) 구현이 매우 간단(3중 for문) DP적 성격 → dp[k][i][j] = 정점 집합 {1…k}만 거쳐서 i→j 가는 최단 거리3️⃣ 시간 복잡도O(N³) 따라서 N ≤ 400 정도에서 자주 쓰임 (백준에서 플로이드 관련 문제 대부분 N ≤ 400). 메모리 복잡도: O(N²)4️⃣ 구현 방법 초기화 인접 행렬 dist[i][j] 생성 i == j → 0 간선 존재 → 해당 가중치 간선 없음 → INF(무한대) 점화식 적용 for (k = 1 ~ N) // 거쳐가는 노드 for (i = 1 ~ N) // 출발 노드 for (j = 1 ~ N) // 도착 노드 if (dist[i][j] &gt; dist[i][k] + dist[k][j]) dist[i][j] = dist[i][k] + dist[k][j] 5️⃣ 기본 코드 (Java) ```javaimport java.util.*; public class FloydWarshall { static final int INF = 1000000000; // 충분히 큰 값 static int n, m; static int[][] dist;public static void main(String[] args) { Scanner sc = new Scanner(System.in); n = sc.nextInt(); // 정점 개수 m = sc.nextInt(); // 간선 개수 dist = new int[n+1][n+1]; // 초기화 for (int i = 1; i &lt;= n; i++) { Arrays.fill(dist[i], INF); dist[i][i] = 0; } // 간선 입력 for (int i = 0; i &lt; m; i++) { int a = sc.nextInt(); int b = sc.nextInt(); int c = sc.nextInt(); dist[a][b] = Math.min(dist[a][b], c); // 여러 간선 있을 수 있음 } // 플로이드-워셜 for (int k = 1; k &lt;= n; k++) { for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { if (dist[i][j] &gt; dist[i][k] + dist[k][j]) { dist[i][j] = dist[i][k] + dist[k][j]; } } } } // 결과 출력 for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { if (dist[i][j] == INF) System.out.print(\"INF \"); else System.out.print(dist[i][j] + \" \"); } System.out.println(); }} } ```경로 복원 최단 거리 값뿐만 아니라 실제 경로를 추적하려면, next[i][j] 배열을 둔다 next[i][j] = j (i→j 직접 연결일 때)로 초기화 업데이트할 때 경유지 k를 통해 최단 거리가 줄어들면 next[i][j] = next[i][k]```javaint[][] next = new int[n+1][n+1];// 초기화for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { if (i == j) next[i][j] = i; else if (dist[i][j] &lt; INF) next[i][j] = j; else next[i][j] = -1; }}// 플로이드-워셜 중 갱신if (dist[i][j] &gt; dist[i][k] + dist[k][j]) { dist[i][j] = dist[i][k] + dist[k][j]; next[i][j] = next[i][k];}// 경로 복원 함수List getPath(int u, int v) { if (next[u][v] == -1) return new ArrayList&lt;&gt;(); List path = new ArrayList&lt;&gt;(); path.add(u); while (u != v) { u = next[u][v]; path.add(u); } return path;}```7️⃣ 자주 사용하는 곳 모든 정점 쌍 최단 거리 필요할 때 (네트워크, 물류 최적 경로, 도시 간 최단 거리) 그래프 크기가 작을 때 (N ≤ 400 정도) 음수 가중치 간선이 포함될 수 있을 때 (다익스트라는 음수 간선 불가능하지만 플로이드-워셜은 가능)" }, { "title": "[알고리즘] 다익스트라 알고리즘 (Dijkstra)", "url": "/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC/", "categories": "Coding Test, Algorithm", "tags": "java, algorithm, dijkstra", "date": "2025-08-06 02:40:00 +0900", "snippet": "다익스트라(Dijkstra) 알고리즘에 대해 공부 후 정리하였습니다.다익스트라 알고리즘1️⃣ 개념가중치가 있는 그래프에서 하나의 시작 정점으로부터 다른 모든 정점까지의 최단 거리를 구하는 알고리즘 BFS의 가중치 버전이라고 생각 가능 (BFS는 모든 간선 가중치가 1일 때 다익스트라와 동일)2️⃣ 특징 Greedy + DP 성격을 동시에 가짐 각 단계에서 가장 가까운 정점을 선택하고, 그 경로를 확정 선택된 최단 거리를 기반으로 다른 거리 갱신 음수 가중치 불가 (음수 간선이 있으면 벨만-포드 사용) 우선순위 큐를 쓰면 O(E log V)에 동작 모든 정점의 최단 거리를 한 번에 구할 수 있음3️⃣ 시간 복잡도 구현 방식 자료구조 시간 복잡도 기본 배열 배열 O(V²) 개선 PriorityQueue(최소 힙) O(E log V) V: 정점 개수 / E: 간선 개수 E log V 방식이 대부분의 경우 빠름 (희소 그래프일 때 유리)4️⃣ 구현 방법 시작 정점의 거리를 0으로 설정, 나머지는 무한대 방문하지 않은 정점 중 거리가 가장 짧은 정점 선택 선택한 정점을 거쳐가는 경로로 다른 정점 거리 갱신 모든 정점이 처리될 때까지 반복5️⃣ 기본 코드 (PriorityQueue 사용)import java.util.*;class Node implements Comparable&lt;Node&gt; { int vertex, cost; public Node(int vertex, int cost) { this.vertex = vertex; this.cost = cost; } public int compareTo(Node o) { return this.cost - o.cost; // 최소 힙 }}public class DijkstraExample { static final int INF = Integer.MAX_VALUE; static List&lt;List&lt;Node&gt;&gt; graph = new ArrayList&lt;&gt;(); static int[] dist; public static void main(String[] args) { int V = 5; // 정점 개수 int E = 6; // 간선 개수 dist = new int[V + 1]; // 그래프 초기화 for (int i = 0; i &lt;= V; i++) { graph.add(new ArrayList&lt;&gt;()); } // 예시 간선 (양방향) addEdge(1, 2, 2); addEdge(1, 3, 5); addEdge(2, 3, 1); addEdge(2, 4, 2); addEdge(3, 4, 3); addEdge(4, 5, 1); dijkstra(1); for (int i = 1; i &lt;= V; i++) { System.out.println(\"1 → \" + i + \" 최단 거리: \" + (dist[i] == INF ? \"INF\" : dist[i])); } } static void addEdge(int u, int v, int w) { graph.get(u).add(new Node(v, w)); graph.get(v).add(new Node(u, w)); // 양방향이면 필요 } static void dijkstra(int start) { PriorityQueue&lt;Node&gt; pq = new PriorityQueue&lt;&gt;(); Arrays.fill(dist, INF); dist[start] = 0; pq.offer(new Node(start, 0)); while (!pq.isEmpty()) { Node now = pq.poll(); int cur = now.vertex; int curCost = now.cost; // 이미 처리된 거리보다 크면 무시 if (curCost &gt; dist[cur]) continue; for (Node next : graph.get(cur)) { int newDist = dist[cur] + next.cost; if (newDist &lt; dist[next.vertex]) { dist[next.vertex] = newDist; pq.offer(new Node(next.vertex, newDist)); } } } }}" }, { "title": "[알고리즘] 동적 계획법(DP: Dynamic Programming)", "url": "/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-DP/", "categories": "Coding Test, Algorithm", "tags": "java, algorithm, dp", "date": "2025-08-05 02:40:00 +0900", "snippet": "동적 계획법(DP) 알고리즘에 대해 공부 후 정리하였습니다.동적 계획법(DP: Dynamic Programming)1️⃣ DP란?큰 문제를 작은 문제로 나누고, 중복되는 작은 문제를 한 번만 풀어서 그 결과를 저장해두고 재사용하여 전체 문제를 해결하는 기법입니다.2️⃣ DP의 핵심 조건 (2가지) 중복 부분 문제 (Overlapping Subproblems) : 같은 계산을 여러 번 반복하는 문제 최적 부분 구조 (Optimal Substructure) : 큰 문제의 최적해가 작은 문제의 최적해로 구성됨3️⃣ DP의 시간 복잡도DP의 시간 복잡도는 일반적으로 O(상태 개수 × 상태 전이 계산 시간) 으로 계산됩니다. 피보나치 (Top-down / Bottom-up): 상태 개수 = n, 전이 시간 = O(1) → O(n) LCS (Longest Common Subsequence): 상태 개수 = n × m, 전이 시간 = O(1) → O(nm) 배낭 문제: 상태 개수 = n × W, 전이 시간 = O(1) → O(nW)✅ DP 시간 복잡도 계산 팁 배열 크기 = 상태 개수 한 상태에서 다음 상태로 가는 경우의 수 = 전이 계산 시간 곱하면 총 시간 복잡도4️⃣ DP 유형 분류 시간 복잡도는 동일함 유형 설명 실제 실행 시간 효과적인 예시 예시 Top-Down 재귀 + 메모이제이션 느림 테이블의 일부만 채워야 할 때, 테이블을 채우는 순서가 복잡할 때 f(n) = f(n-1) + f(n-2) Bottom-Up 반복문 + 배열 빠름 테이블을 채우는 순서가 직관적으로 보일 때 dp[i] = dp[i-1] + dp[i-2] 5️⃣ DP 문제 풀이 팁 테이블 정하기 (ex: dp[i] = i를 1로 만드는 최소 연산 횟수) 점화식 구하기 (ex: dp[i] = dp[i-1] + dp[i-2]) 초기값 정하기 (ex: dp[0], dp[1]) 메모이제이션 or 반복문 선택 재귀(Top-down): 간단한 구조, but 느릴 수 있음 반복문(Bottom-up): 빠르고 안전, but 구현이 복잡할 수 있음 작은 입력부터 차례로 채우기 (ex: dp[2], dp[3], …, dp[n] 순서로)Prefix Sum (누적 합)1️⃣ 개념배열의 부분합을 빠르게 구하기 위해, 미리 합을 구해놓은 배열을 만드는 기법 구간 합 쿼리를 O(1)에 처리 가능2️⃣ 특징 배열 변경이 없는 경우 매우 효율적 (변경이 있으면 Fenwick Tree, Segment Tree 고려) 1D, 2D, 3D 등 다차원 배열에도 적용 가능3️⃣ 시간 복잡도 전처리: O(n) 구간합 질의: O(1)4️⃣ 구현 방법 prefix[i] = arr[0] ~ arr[i] 합 구간합 (l, r) = prefix[r] - prefix[l-1]5️⃣ 예시 코드 (1D)public class PrefixSumExample { public static void main(String[] args) { int[] arr = {2, 4, 5, 7, 1}; int n = arr.length; int[] prefix = new int[n + 1]; // 1-based indexing // 전처리 for (int i = 1; i &lt;= n; i++) { prefix[i] = prefix[i - 1] + arr[i - 1]; } // 구간합 예시: arr[1..3] (0-indexed: 4+5+7) int l = 2, r = 4; // 1-based index int sum = prefix[r] - prefix[l - 1]; System.out.println(\"구간합: \" + sum); // 출력: 13 }}" }, { "title": "[Java] 기본 정렬 메소드와 객체 정렬", "url": "/posts/%EC%9E%90%EB%B0%94-%EA%B3%B5%EB%B6%805/", "categories": "Coding Test, Study", "tags": "java", "date": "2025-08-05 02:30:00 +0900", "snippet": "Arrays.sort, Collections.sort, 커스텀 Comparator, 객체 정렬까지 정렬의 모든 것을 정리했습니다.1️⃣ 기본 정렬🔹 1-1. 기본 배열 정렬 (Arrays.sort) 기본형 배열은 Dual-Pivot Quicksort 사용 (평균 O(N log N)) 참조형 배열은 TimSort 사용 (O(N log N))int[] arr = {5, 1, 4, 2, 3};Arrays.sort(arr); // 오름차순System.out.println(Arrays.toString(arr)); // [1, 2, 3, 4, 5]🔹 1-2. 리스트 정렬 (Collections.sort) 내부적으로 List를 배열로 변환 후 TimSort 적용 오름차순은 자연 순서(Natural Order)로 동작List&lt;Integer&gt; list = Arrays.asList(5, 1, 4, 2, 3);Collections.sort(list); // 오름차순System.out.println(list); // [1, 2, 3, 4, 5]2️⃣ 내림차순 정렬🔹 2-1. 배열 내림차순 (Integer[] 사용) 원시 자료형 불가능, 객체 자료형으로 선언 필수 int[] 는 불가능 → Integer[]로 박싱해야 함Integer[] arr = {5, 1, 4, 2, 3};Arrays.sort(arr, Collections.reverseOrder());System.out.println(Arrays.toString(arr)); // [5, 4, 3, 2, 1]🔹 2-2. 리스트 내림차순List&lt;Integer&gt; list = Arrays.asList(5, 1, 4, 2, 3);list.sort(Collections.reverseOrder()); // Collections.sort(list, Collections.reverseOrder()) 도 가능System.out.println(list); // [5, 4, 3, 2, 1]3️⃣ 커스텀 정렬 (Comparator 사용)🔹 3-1. 람다로 바로 정의 문자열 길이 기준 오름차순 정렬 a - b 대신 Integer.compare(a, b) 권장 (오버플로 방지)String[] arr = {\"apple\", \"banana\", \"kiwi\", \"grape\"};Arrays.sort(arr, (a, b) -&gt; Integer.compare(a.length(), b.length())); System.out.println(Arrays.toString(arr)); // [kiwi, apple, grape, banana]🔹 3-2. Collections.sort()에 바로 ComparatorList&lt;String&gt; list = Arrays.asList(\"apple\", \"banana\", \"kiwi\", \"grape\");Collections.sort(list, (a, b) -&gt; b.compareTo(a)); // 내림차순System.out.println(list); // [kiwi, grape, banana, apple]Collections.sort(list, new Comparator&lt;String&gt;() { \t @Override public int compare(String o1, String o2) { return o1.length() - o2.length(); }});4️⃣ 객체에서 정렬🔹 4-1. Comparable 인터페이스 구현 Comparable은 클래스 내부에서 기본 정렬 기준 정의 Arrays.sort() / Collections.sort() 호출 시 자동 적용 예시: 사람(Person)을 나이(age) 오름차순 정렬class Person implements Comparable&lt;Person&gt; { String name; int age; Person(String name, int age) { this.name = name; this.age = age; } // Comparable 인터페이스 구현 @Override public int compareTo(Person o) { return Integer.compare(this.age, o.age); // 나이 오름차순 // return this.age - other.age; // 오름차순 // return o.age - this.age; // 내림차순 } @Override public String toString() { return name + \" (\" + age + \")\"; }}public class Main { public static void main(String[] args) { Person[] arr = { new Person(\"Kim\", 30), new Person(\"Lee\", 20), new Person(\"Park\", 25) }; Arrays.sort(arr); List&lt;Person&gt; list = new ArrayList&lt;&gt;(); list.add(new Person(\"Alice\", 30)); list.add(new Person(\"Bob\", 20)); list.add(new Person(\"Charlie\", 25)); Collections.sort(list); System.out.println(Arrays.toString(arr)); // [Lee (20), Park (25), Kim (30)] }}🔹 4-2. Comparator로 외부에서 정렬 정의 정렬 시 Comparator를 익명 클래스/람다로 직접 전달 정렬 기준을 외부에서 유연하게 정의Arrays.sort(arr, new Comparator&lt;Person&gt;() { @Override public int compare(Person p1, Person p2) { return p2.name.compareTo(p1.name); // 이름 내림차순 }});Comparator&lt;Person&gt; comparator = new Comparator&lt;Person&gt;() { // 객체 정의 @Override public int compare(Person a, Person b) { return b.age - a.age; // 나이 내림차순 }};Collections.sort(list, comparator);// 람다 이용Arrays.sort(arr, (p1, p2) -&gt; p1.name.compareTo(p2.name)); // 이름 오름차순Collections.sort(list, (a, b) -&gt; b.age - a.age); // 나이 내림차순public class Main { public static void main(String[] args) { List&lt;Person&gt; list = new ArrayList&lt;&gt;(); list.add(new Person(\"Alice\", 30)); list.add(new Person(\"Bob\", 20)); list.add(new Person(\"Charlie\", 25)); // 1) 나이 오름차순 list.sort(new Comparator&lt;Person&gt;() { @Override public int compare(Person a, Person b) { return a.age - b.age; } }); // 2) 또는 람다 사용 (Java 8+) list.sort((a, b) -&gt; a.age - b.age); // 3) 이름 기준 내림차순 list.sort((a, b) -&gt; b.name.compareTo(a.name)); System.out.println(list); }}🔹 4-3. 다중 조건 정렬 (예: 나이 오름차순, 같으면 이름 사전순)Arrays.sort(arr, (p1, p2) -&gt; { if (p1.age == p2.age) { return p1.name.compareTo(p2.name); } return Integer.compare(p1.age, p2.age);});list.sort((a, b) -&gt; { if (a.age == b.age) { return a.name.compareTo(b.name); // 이름 오름차순 } return a.age - b.age; // 나이 오름차순});5️⃣ Stream 정렬List&lt;String&gt; list = Arrays.asList(\"apple\", \"banana\", \"kiwi\", \"grape\");list.stream() .sorted((a, b) -&gt; b.length() - a.length()) // 길이 내림차순 .forEach(System.out::println); 정렬 시 주의할 점 int[]는 Comparator 불가 → Integer[]로 변환 compare(a, b)는 음수 → a &lt; b 0 → a == b 양수 → a &gt; b 문자열 비교는 compareTo() 사용 (사전순) 6️⃣ 전체 비교 정리 정렬 방법 적용 대상 정렬 기준 성능 (평균) 특징 / 비고 Arrays.sort(int[]) 기본형 배열 (int[], double[] 등) 오름차순 (변경 불가) O(N log N)(Dual-Pivot QuickSort) 빠르고 메모리 효율적, Comparator 불가 Arrays.sort(Integer[]) 참조형 배열 (Integer[], String[], 객체[]) 오름/내림차순Comparator 가능 O(N log N)(TimSort) null 허용, Comparator로 커스텀 가능 Collections.sort(List&lt;T&gt;) List (ArrayList, LinkedList 등) 오름/내림차순Comparator 가능 O(N log N)(TimSort) 내부적으로 배열로 변환 후 정렬 List.sort(Comparator) List Comparator 필수 O(N log N)(TimSort) Java 8+, 람다 사용에 적합 Comparable 구현 객체 배열 / 리스트 compareTo()로 정의된 기본 정렬 O(N log N) 클래스 내부에서 기본 정렬 규칙 고정 Comparator 구현 객체 배열 / 리스트 외부에서 다중 조건 가능 O(N log N) 람다식 활용 가능, 다중 기준 정렬 편리 Stream.sorted() Stream 데이터 기본 정렬 / Comparator O(N log N) 정렬 후 가공·출력 파이프라인 가능 " }, { "title": "[알고리즘] 최소 신장 트리(MST) : 크루스칼 알고리즘, 프림 알고리즘", "url": "/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-MST/", "categories": "Coding Test, Algorithm", "tags": "java, algorithm, mst, kruskal, prim", "date": "2025-08-04 02:30:00 +0900", "snippet": "최소 신장 트리(MST)의 크루스칼(Kruskal) 알고리즘과 프림(Prim) 알고리즘에 대해 공부 후 정리하였습니다.1. 최소 신장 트리 (MST: Minimum Spanning Tree)1️⃣ 개념 신장 트리(Spanning Tree) 그래프의 모든 정점을 포함 간선 수 = 정점 수 - 1 사이클이 없음 최소 신장 트리 가능한 모든 신장 트리 중 간선 가중치의 합이 최소인 트리 조건 무방향, 가중치 그래프 연결 그래프 (모든 정점이 연결되어 있어야 함) 2️⃣ MST 구하는 방법 크루스칼(Kruskal) → 간선 중심, 정렬 + Union-Find 프림(Prim) → 정점 중심, 우선순위 큐2. 크루스칼 알고리즘 (Kruskal)1️⃣ 개념간선을 가중치 오름차순으로 정렬 후, 가장 작은 간선부터 사이클이 생기지 않도록 선택 Union-Find으로 사이클 판별 대표적인 그리디(Greedy) 알고리즘2️⃣ 특징 간선 중심 (Edge-based) 유니온 파인드(Disjoint Set) 자료구조를 사용 모든 간선을 정렬 → 사이클 검사하며 선택 간선이 적은 희소 그래프(Sparse Graph)에서 유리3️⃣ 시간 복잡도 O(E log E) (E는 간선 수) → 정렬에 걸리는 시간 유니온 파인드는 거의 상수 시간 (O(α(N)))4️⃣ 구현 절차 모든 간선을 가중치 기준 오름차순 정렬 Union-Find 초기화 가중치가 가장 작은 간선 선택 후 두 정점이 같은 집합이면 무시 다른 집합이면 같은 그룹으로 만들고, MST에 간선 추가 N-1개의 간선 선택 시 종료, 아니라면 3번 과정 반복5️⃣ 기본 코드import java.util.*;class Edge implements Comparable&lt;Edge&gt; { int u, v, weight; Edge(int u, int v, int weight) { this.u = u; this.v = v; this.weight = weight; } @Override public int compareTo(Edge other) { return this.weight - other.weight; }}class UnionFind { int[] parent; UnionFind(int size) { parent = new int[size]; for (int i = 0; i &lt; size; i++) parent[i] = i; } int find(int x) { if (parent[x] == x) return x; return parent[x] = find(parent[x]); } boolean union(int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX == rootY) return false; parent[rootY] = rootX; return true; }}public class KruskalMST { public static int kruskal(int V, List&lt;Edge&gt; edges) { Collections.sort(edges); // 간선 가중치 기준 정렬 UnionFind uf = new UnionFind(V); int totalWeight = 0; for (Edge edge : edges) { if (uf.union(edge.u, edge.v)) { totalWeight += edge.weight; } } return totalWeight; } public static void main(String[] args) { int V = 4; List&lt;Edge&gt; edges = new ArrayList&lt;&gt;(); edges.add(new Edge(0, 1, 1)); edges.add(new Edge(1, 2, 4)); edges.add(new Edge(0, 2, 3)); edges.add(new Edge(2, 3, 2)); edges.add(new Edge(1, 3, 5)); System.out.println(\"Minimum Spanning Tree Weight: \" + kruskal(V, edges)); }}유니온 파인드를 클래스로 분리하지 않은 코드 import java.util.*;class Edge implements Comparable&lt;Edge&gt; {int u, v, weight;Edge(int u, int v, int weight) {this.u = u; this.v = v; this.weight = weight;}@Overridepublic int compareTo(Edge o) {return this.weight - o.weight;}}public class KruskalMST {static int[] parent; public static int find(int x) { if (parent[x] == x) return x; return parent[x] = find(parent[x]); } public static void union(int a, int b) { a = find(a); b = find(b); if (a != b) parent[b] = a; } public static void main(String[] args) { int V = 4; int E = 5; List&lt;Edge&gt; edges = Arrays.asList( new Edge(0, 1, 10), new Edge(0, 2, 6), new Edge(0, 3, 5), new Edge(1, 3, 15), new Edge(2, 3, 4) ); Collections.sort(edges); // 간선 정렬 parent = new int[V]; for (int i = 0; i &lt; V; i++) parent[i] = i; int mstWeight = 0; for (Edge edge : edges) { if (find(edge.u) != find(edge.v)) { union(edge.u, edge.v); mstWeight += edge.weight; } } System.out.println(\"MST 가중치 합: \" + mstWeight); }} 3. 프림 알고리즘 (Prim)1️⃣ 개념임의의 시작 정점에서 시작 → MST에 속하지 않은 정점 중 최소 가중치 간선을 선택하며 확장 그리디 방식2️⃣ 특징 정점 중심 (Vertex-based) 우선순위 큐(PriorityQueue)를 사용하여 가장 작은 간선을 선택 간선이 많은 밀집 그래프(Dense Graph)에서 유리 BFS와 비슷하게 동작하지만, 간선 선택 기준이 다름3️⃣ 시간 복잡도O(E log V) (우선순위 큐 사용 시)4️⃣ 구현 절차 임의의 시작 정점 선택 후 MST에 추가 해당 정점과 연결된 간선들을 우선순위 큐에 넣기 우선순위 큐에서 최소 가중치 간선을 꺼내기 해당 간선이 MST에 포함된 두 정점을 연결하면 continue 연결된 정점이 MST에 없으면 추가 새로 추가된 정점에서 연결된 간선을 우선순위 큐에 넣기 모든 정점이 MST에 포함될 때까지 3 ~ 4 과정 반복5️⃣ 기본 코드import java.util.*;class PrimEdge implements Comparable&lt;PrimEdge&gt; { int to, weight; PrimEdge(int to, int weight) { this.to = to; this.weight = weight; } @Override public int compareTo(PrimEdge o) { return this.weight - o.weight; }}public class PrimMST { public static void main(String[] args) { int V = 4; List&lt;List&lt;PrimEdge&gt;&gt; graph = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; V; i++) graph.add(new ArrayList&lt;&gt;()); // 무방향 간선 추가 graph.get(0).add(new PrimEdge(1, 10)); graph.get(1).add(new PrimEdge(0, 10)); graph.get(0).add(new PrimEdge(2, 6)); graph.get(2).add(new PrimEdge(0, 6)); graph.get(0).add(new PrimEdge(3, 5)); graph.get(3).add(new PrimEdge(0, 5)); graph.get(1).add(new PrimEdge(3, 15)); graph.get(3).add(new PrimEdge(1, 15)); graph.get(2).add(new PrimEdge(3, 4)); graph.get(3).add(new PrimEdge(2, 4)); boolean[] visited = new boolean[V]; PriorityQueue&lt;PrimEdge&gt; pq = new PriorityQueue&lt;&gt;(); pq.offer(new PrimEdge(0, 0)); // 시작 정점(0), 가중치 0 int mstWeight = 0; while (!pq.isEmpty()) { PrimEdge current = pq.poll(); if (visited[current.to]) continue; visited[current.to] = true; mstWeight += current.weight; for (PrimEdge next : graph.get(current.to)) { if (!visited[next.to]) { pq.offer(next); } } } System.out.println(\"MST 가중치 합: \" + mstWeight); }}클래스로 분리한 동일 코드 import java.util.*;class Node implements Comparable&lt;Node&gt; {int vertex, weight; Node(int vertex, int weight) { this.vertex = vertex; this.weight = weight; } @Override public int compareTo(Node other) { return this.weight - other.weight; }}public class PrimMST {public static int prim(int V, List&lt;List&lt;Node&gt;&gt; graph) {boolean[] visited = new boolean[V];PriorityQueue&lt;Node&gt; pq = new PriorityQueue&lt;&gt;();pq.offer(new Node(0, 0)); // 시작 정점int totalWeight = 0; while (!pq.isEmpty()) { Node cur = pq.poll(); if (visited[cur.vertex]) continue; visited[cur.vertex] = true; totalWeight += cur.weight; for (Node neighbor : graph.get(cur.vertex)) { if (!visited[neighbor.vertex]) { pq.offer(new Node(neighbor.vertex, neighbor.weight)); } } } return totalWeight; } public static void main(String[] args) { int V = 4; List&lt;List&lt;Node&gt;&gt; graph = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; V; i++) graph.add(new ArrayList&lt;&gt;()); graph.get(0).add(new Node(1, 1)); graph.get(0).add(new Node(2, 3)); graph.get(1).add(new Node(0, 1)); graph.get(1).add(new Node(2, 4)); graph.get(1).add(new Node(3, 5)); graph.get(2).add(new Node(0, 3)); graph.get(2).add(new Node(1, 4)); graph.get(2).add(new Node(3, 2)); graph.get(3).add(new Node(1, 5)); graph.get(3).add(new Node(2, 2)); System.out.println(\"Minimum Spanning Tree Weight: \" + prim(V, graph)); }} 4. 비교 구분 크루스칼(Kruskal) 프림(Prim) 중심 간선 중심 정점 중심 자료구조 간선 리스트 + 정렬 + Union-Find 인접 리스트 + 우선순위 큐 시간 복잡도 O(E log E) O(E log V) 유리한 경우 희소 그래프 밀집 그래프 구현 난이도 중간 (Union-Find 필요) 중간 (PriorityQueue 필요) " }, { "title": "[알고리즘] 유니온 파인드 (Union-Find)", "url": "/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%9C%A0%EB%8B%88%EC%98%A8%ED%8C%8C%EC%9D%B8%EB%93%9C/", "categories": "Coding Test, Algorithm", "tags": "java, algorithm, union-find", "date": "2025-08-04 02:10:00 +0900", "snippet": "유니온 파인드(Union-Find) 알고리즘에 대해 공부 후 정리하였습니다.유니온 파인드 (Union Find)1️⃣ 개념서로소 집합(Disjoint Set) 을 관리하는 자료구조 두 노드가 같은 집합에 속하는지 판별하거나, 두 집합을 합치는 연산을 효율적으로 수행 주로 그래프의 연결 관계 관리에 사용 (예: 크루스칼 MST)2️⃣ 주요 연산Find(x) 원소 x가 속한 집합(대표 노드)을 찾음 경로 압축(Path Compression) 최적화를 적용하면 트리가 납작해짐Union(a, b) 원소 a와 b가 속한 집합을 합침 랭크/사이즈 기반 합치기(Union by Rank/Size)로 트리 높이 최소화3️⃣ 특징 간선 연결 여부나 집합의 동질성을 빠르게 확인 가능 그래프 문제에서 사이클 판별과 연결 요소 관리에 매우 효율적 크루스칼 알고리즘에서 필수4️⃣ 시간 복잡도 단순 구현: Find = O(H) (H: 트리 높이) 경로 압축 + 랭크/사이즈 최적화 적용: 거의 O(1) (정확히는 α(N), 아커만 함수의 역함수)5️⃣ 기본 코드 (최적화 없음)public class UnionFindBasic { static int[] parent; // 초기화 public static void init(int n) { parent = new int[n + 1]; for (int i = 1; i &lt;= n; i++) parent[i] = i; } // Find public static int find(int x) { if (parent[x] == x) return x; return find(parent[x]); // 경로 압축 없음 } // Union public static void union(int a, int b) { a = find(a); b = find(b); if (a != b) parent[b] = a; } public static void main(String[] args) { init(5); union(1, 2); union(3, 4); System.out.println(find(2) == find(1)); // true System.out.println(find(2) == find(3)); // false }}6️⃣ 최적화 적용 코드방법 1. 경로 압축 (Path Compression) Find 실행 시, 탐색 경로의 모든 노드를 루트에 직접 연결 다음 호출 시 O(1)에 가까운 시간 복잡도public static int find(int x) { if (parent[x] != x) { parent[x] = find(parent[x]); // 루트를 바로 연결 } return parent[x];}방법 2. 랭크/사이즈 기반 합치기 (Union by Rank/Size) 두 집합 합칠 때 작은 트리를 큰 트리에 붙임 트리 높이가 최소화되어 성능 향상static int[] rank;public static void init(int n) { parent = new int[n + 1]; rank = new int[n + 1]; for (int i = 1; i &lt;= n; i++) { parent[i] = i; rank[i] = 1; // 높이 1 }}public static void union(int a, int b) { a = find(a); b = find(b); if (a != b) { if (rank[a] &lt; rank[b]) { parent[a] = b; } else if (rank[a] &gt; rank[b]) { parent[b] = a; } else { parent[b] = a; rank[a]++; } }}최적화 방법 2가지 결합public class UnionFindOptimized { static int[] parent, rank; public static void init(int n) { parent = new int[n + 1]; rank = new int[n + 1]; for (int i = 1; i &lt;= n; i++) { parent[i] = i; rank[i] = 1; } } public static int find(int x) { if (parent[x] != x) { parent[x] = find(parent[x]); // 경로 압축 } return parent[x]; } public static void union(int a, int b) { a = find(a); b = find(b); if (a != b) { if (rank[a] &lt; rank[b]) { parent[a] = b; } else if (rank[a] &gt; rank[b]) { parent[b] = a; } else { parent[b] = a; rank[a]++; } } } public static void main(String[] args) { init(5); union(1, 2); union(3, 4); union(2, 3); System.out.println(find(4) == find(1)); // true }}유니온 파인드 활용1️⃣ 무방향 그래프에서 사이클 판별 무방향 그래프에서 간선을 하나씩 추가하면서, 연결하려는 두 노드가 이미 같은 집합에 속해 있다면 → 사이클 발생 Union-Find로 매우 빠르게 판별 가능 (O(E α(N)))import java.util.*;public class CycleDetectionUF { static int[] parent, rank; public static void init(int n) { parent = new int[n + 1]; rank = new int[n + 1]; for (int i = 1; i &lt;= n; i++) { parent[i] = i; rank[i] = 1; } } public static int find(int x) { if (parent[x] != x) parent[x] = find(parent[x]); return parent[x]; } public static boolean union(int a, int b) { a = find(a); b = find(b); if (a == b) return false; // 이미 같은 집합 → 사이클 발생 if (rank[a] &lt; rank[b]) parent[a] = b; else if (rank[a] &gt; rank[b]) parent[b] = a; else { parent[b] = a; rank[a]++; } return true; } public static void main(String[] args) { int n = 5; // 노드 개수 int[][] edges = { {1, 2}, {1, 3}, {2, 3}, // (2, 3) 추가 시 사이클 발생 {3, 4}, {4, 5} }; init(n); boolean cycle = false; for (int[] e : edges) { if (!union(e[0], e[1])) { cycle = true; break; } } System.out.println(\"사이클 존재 여부: \" + cycle); }}2️⃣ 2D 격자 병합 문제 (예: 같은 색 영역 합치기) N x M 격자에서 같은 색(또는 값)이 상하좌우로 연결되어 있으면 같은 그룹으로 묶기 Union-Find를 이용하면 DFS/BFS 없이도 그룹 수 계산 가능public class GridUnionFind { static int[] parent, rank; static int N, M; public static void init(int size) { parent = new int[size]; rank = new int[size]; for (int i = 0; i &lt; size; i++) { parent[i] = i; rank[i] = 1; } } public static int find(int x) { if (parent[x] != x) parent[x] = find(parent[x]); return parent[x]; } public static void union(int a, int b) { a = find(a); b = find(b); if (a != b) { if (rank[a] &lt; rank[b]) parent[a] = b; else if (rank[a] &gt; rank[b]) parent[b] = a; else { parent[b] = a; rank[a]++; } } } public static void main(String[] args) { int[][] grid = { {1, 1, 0}, {1, 0, 0}, {0, 0, 1} }; N = grid.length; M = grid[0].length; init(N * M); // 방향: 상하좌우 int[] dx = {-1, 1, 0, 0}; int[] dy = {0, 0, -1, 1}; for (int x = 0; x &lt; N; x++) { for (int y = 0; y &lt; M; y++) { for (int d = 0; d &lt; 4; d++) { int nx = x + dx[d]; int ny = y + dy[d]; if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &lt; M) { if (grid[x][y] == grid[nx][ny]) { union(x * M + y, nx * M + ny); } } } } } // 고유 그룹 수 세기 java.util.Set&lt;Integer&gt; groups = new java.util.HashSet&lt;&gt;(); for (int i = 0; i &lt; N * M; i++) { groups.add(find(i)); } System.out.println(\"고유 그룹 수: \" + groups.size()); }}" }, { "title": "[알고리즘] 위상 정렬(Topological Sort)", "url": "/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%9C%84%EC%83%81%EC%A0%95%EB%A0%AC/", "categories": "Coding Test, Algorithm", "tags": "java, algorithm, topological-sort", "date": "2025-08-03 02:30:00 +0900", "snippet": "위상 정렬(Topological Sort)에 대해 공부 후 정리하였습니다.위상 정렬 (Topological Sort)1️⃣ 개념방향 그래프에서 사이클이 없는 경우(DAG), 간선으로 주어진 정점 간 선후 관계를 위배하지 않도록 나열하는 알고리즘 간선 (u → v)가 있으면 정렬 결과에서 u가 반드시 v보다 앞에 나와야 함 주로 선행 조건이 있는 작업 순서를 구할 때 사용 예: 선수 과목이 있는 수강 순서, 작업 의존성 문제2️⃣ 특징 사이클이 없는 방향 그래프(DAG)에서만 가능 정렬 결과는 유일하지 않을 수 있음 (여러 가능한 순서 존재 가능) 보통 큐(BFS) 또는 재귀(DFS)로 구현 가능 BFS 방식이 코테에서 더 자주 쓰임 (Kahn’s Algorithm) 위상 정렬의 결과에 모든 정점이 포함되지 않는다면 사이클이 존재한다는 것 (사이클 존재 여부는 위상 정렬 실행 후 결과 리스트 크기로 판별) 3️⃣ 시간 복잡도O(V + E) V: 노드(정점) 개수 E: 간선 개수 각 노드/간선을 한 번씩만 처리4️⃣ 구현 방법 (BFS / Kahn’s Algorithm) 모든 간선 읽으면서 진입 차수(in-degree) 배열 채우기 (각 노드로 들어오는 간선 개수 기록) 진입 차수(indegree)가 0인 노드들을 큐에 넣기 큐에서 front 노드를 꺼내 결과 리스트에 추가 해당 노드와 연결된 모든 정점의 indegree 값 1 감소시키기 진입 차수가 0이 된 새로운 노드들을 큐에 추가 큐가 빌 때까지 3 ~ 5 과정 반복5️⃣ 기본 코드import java.util.*;public class TopologicalSort { public static void main(String[] args) { int V = 6; List&lt;List&lt;Integer&gt;&gt; graph = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; V; i++) { graph.add(new ArrayList&lt;&gt;()); } // 간선 추가 (예: 5 → 2, 5 → 0, 4 → 0, 4 → 1, 2 → 3, 3 → 1) graph.get(5).add(2); graph.get(5).add(0); graph.get(4).add(0); graph.get(4).add(1); graph.get(2).add(3); graph.get(3).add(1); // 진입 차수 계산 int[] indegree = new int[V]; for (int i = 0; i &lt; V; i++) { for (int next : graph.get(i)) { indegree[next]++; } } // 큐 초기화 Queue&lt;Integer&gt; queue = new ArrayDeque&lt;&gt;(); for (int i = 0; i &lt; V; i++) { if (indegree[i] == 0) { queue.offer(i); } } // 위상 정렬 실행 List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); while (!queue.isEmpty()) { int current = queue.poll(); result.add(current); for (int next : graph.get(current)) { indegree[next]--; if (indegree[next] == 0) { queue.offer(next); } } } // 결과 출력 if (result.size() != V) { System.out.println(\"사이클이 존재하여 위상 정렬 불가능\"); } else { System.out.println(\"위상 정렬 결과: \" + result); } }}" }, { "title": "[알고리즘] 투 포인터(Two Pointers)와 슬라이딩 윈도우(Sliding Window)", "url": "/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%88%AC%ED%8F%AC%EC%9D%B8%ED%84%B0/", "categories": "Coding Test, Algorithm", "tags": "java, algorithm, two-pointers, sliding-window", "date": "2025-08-02 02:30:00 +0900", "snippet": "투 포인터(Two Pointers)와 슬라이딩 윈도우(Sliding Window) 대해 공부 후 정리하였습니다.1. 투 포인터 (Two Pointers)1️⃣ 개념두 개의 포인터(인덱스)를 이용해 배열이나 리스트를 한 번에 탐색하는 방식입니다. 이분 탐색으로 투 포인터 문제를 풀 수 있는 경우가 많고, 투 포인터로 이분 탐색 문제를 풀 수 있는 경우도 많습니다.2️⃣ 특징 브루트포스(O(N²)) 대비 효율적 보통 left와 right 두 개의 변수를 사용 배열을 한 번만 스캔하면서 두 포인터를 조절 정렬 상태나 연속된 구간을 다루는 문제에서 강력함 데이터를 한 방향으로만 이동하면서 조건을 만족하는 부분 구간, 쌍(pair), 합 등을 찾는 데 효율적3️⃣ 시간 복잡도 O(N) (포인터들이 한 번만 끝까지 이동) 경우에 따라 정렬이 필요하면 O(N log N) + O(N)4️⃣ 기본 코드 (합이 특정 값인 두 수 찾기)조건: arr가 오름차순 정렬되어 있어야 함import java.util.Arrays;public class TwoPointersExample { public static void main(String[] args) { int[] arr = {1, 2, 4, 7, 11, 15}; int target = 15; int left = 0; int right = arr.length - 1; while (left &lt; right) { int sum = arr[left] + arr[right]; if (sum == target) { System.out.println(arr[left] + \" + \" + arr[right] + \" = \" + target); left++; right--; } else if (sum &lt; target) { left++; } else { right--; } } }}2. 슬라이딩 윈도우 (Sliding Window)3. 비교 구분 투 포인터 (Two Pointers) 슬라이딩 윈도우 (Sliding Window) 개념 두 개의 포인터를 이용해 배열을 탐색하며 조건을 만족하는 구간/쌍을 찾는 방법 고정 길이 또는 가변 길이의 “연속된 구간”을 효율적으로 탐색하는 방법 포인터 이동 보통 left, right가 독립적으로 움직이며 간격이 변함 left와 right가 항상 일정 간격(고정 길이) 또는 조건에 맞춰 한 칸씩 이동 데이터 정렬 필요 여부 합 문제 등에서는 정렬 필요, 부분합 문제에서는 필수 아님 정렬 필요 없음 (단, 연속된 구간 유지 필요) 시간 복잡도 O(N) (정렬 필요 시 O(N log N) + O(N)) O(N) 주요 활용 두 수의 합, 세 수의 합, 중복 제거, 병합 부분합, 최대/최소 합, 문자열 길이 제한 문제 장점 정렬된 상태에서 빠른 탐색 가능 연속 구간 합/길이 문제에 직관적 단점 정렬이 필요한 경우가 많음, 연속되지 않은 쌍 찾기만 가능 고정/연속 구간 문제에 한정 예시 문제 합이 X인 두 수 찾기, 세 수의 합, 중복 제거 연속 부분합 최대, 길이가 K인 부분 배열의 합 " }, { "title": "[알고리즘] 이분 탐색(Binary Search), 매개변수 탐색(Parametric Search)", "url": "/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%9D%B4%EB%B6%84%ED%83%90%EC%83%89/", "categories": "Coding Test, Algorithm", "tags": "java, algorithm, binary-search, parametric-search", "date": "2025-08-01 02:30:00 +0900", "snippet": "이분 탐색(Binary Search)과 매개변수 탐색(Parametric Search)에 대해 공부 후 정리하였습니다.1. 이분 탐색 (Binary Search)추가할 내용 주의 사항 : 무한루프 주의 - start와 end가 1차이날 때 주의깊게 확인 (start+end+1)/2 정렬되어야 함 응용 문제 : 해당 타겟이 몇 개 있는지 찾기 (왼쪽과 오른쪽 위치를 찾아서 계산) upper/lower bound 응용 문제 : 뭔가를 2개 묶은 후, 한쪽의 값을 이분 탐색으로 찾기 -&gt; 시간 단축개념정렬된 데이터에서 원하는 값을 빠르게 찾는 탐색 알고리즘 “중간값(mid)”과 비교해 탐색 범위를 절반씩 줄여가는 방식특징 데이터가 정렬되어 있어야 사용 가능 (오름차순 또는 내림차순) 탐색 범위를 절반씩 줄이므로 효율적 정확히 일치하는 값 뿐만 아니라, 특정 조건을 만족하는 첫 번째/마지막 인덱스 탐색도 가능시간 복잡도정렬된 경우 : O(log N) 매 단계마다 검색 범위가 절반으로 줄어듦 N이 1,000,000 → 약 20번 비교정렬되지 않은 경우 : O(NlogN + logN)기본 코드import java.util.*;public class BinarySearchExample { public static void main(String[] args) { int[] arr = {1, 3, 5, 7, 9, 11, 13}; int target = 7; int index = binarySearch(arr, target); if (index != -1) { System.out.println(target + \" 찾음 (인덱스: \" + index + \")\"); } else { System.out.println(target + \" 없음\"); } } static int binarySearch(int[] arr, int target) { int left = 0; int right = arr.length - 1; while (left &lt;= right) { int mid = (left + right) / 2; if (arr[mid] == target) { return mid; } if (arr[mid] &lt; target) { left = mid + 1; // 오른쪽 절반으로 이동 } else { right = mid - 1; // 왼쪽 절반으로 이동 } } return -1; // 못 찾음 }} Arrays.binarySearch() 정리2. 매개변수 탐색 (Parametric Search)개념이분 탐색을 “정답”이 아닌 “조건”에 적용하는 기법 “가능하다 / 불가능하다”로 판별하며, 답이 될 수 있는 범위에서 조건을 만족하는 최적값을 찾는 방법= 조건을 만족하는 최소/최대값을 구하는 문제인 최적화 문제를 결정 문제로 변환해 이분탐색을 수행하는 것특징 “조건을 만족하는 최대/최소 값”을 구할 때 사용 정답이 수치형 범위(1 ~ 10^9 등)일 때 특히 유용 조건 검증 함수(isPossible)의 시간 복잡도가 O(N) → 전체는 O(N log MaxValue)방법 결정 문제로 변환 가능한 지 확인하기 (최적화 문제) N개를 만들 수 있는 랜선의 최대 길이 (결정 문제) 랜선 길이가 x일 때, 랜선이 N개 이상인가 아닌가 감소/증가 함수인지 확인하기 (일정하지 않으면 이분 탐색 불가능) 📌 구조 답의 범위를 설정 중간값 mid를 답이라고 가정 mid가 조건을 만족하는지 판별 (O(N) 검증 함수) 조건 만족 여부에 따라 탐색 범위를 줄임 조건 만족 → 더 좋은 해(작거나 큰 값)를 찾기 위해 범위 좁힘 조건 불만족 → 반대쪽으로 이동 예시 문제 : 나무 자르기 문제 (백준 2805)N개의 나무 중 H 높이 이상만 잘라서 가져가는데, 가져가는 나무의 합이 M 이상이 되도록 하는 최대 절단기 높이 찾기import java.util.*;public class TreeCutting { static int[] trees; static int N, M; public static void main(String[] args) { Scanner sc = new Scanner(System.in); N = sc.nextInt(); M = sc.nextInt(); trees = new int[N]; int maxTree = 0; for (int i = 0; i &lt; N; i++) { trees[i] = sc.nextInt(); maxTree = Math.max(maxTree, trees[i]); } int left = 0; int right = maxTree; int result = 0; while (left &lt;= right) { int mid = (left + right) / 2; if (isPossible(mid)) { // mid 높이로 잘랐을 때 가능하면 result = mid; left = mid + 1; // 더 높게 자를 수 있는지 탐색 } else { right = mid - 1; // 높이를 낮춰야 함 } } System.out.println(result); } static boolean isPossible(int height) { long sum = 0; for (int tree : trees) { if (tree &gt; height) { sum += (tree - height); } } return sum &gt;= M; }}3. 이분 탐색 &amp; Parametric Search 판별1️⃣ 이분 탐색 (Binary Search) 데이터가 정렬되어 있는가? (오름차순/내림차순, 또는 정렬 가능) 정확히 일치하는 값 또는 조건을 만족하는 첫/마지막 위치를 찾는가? 예: 특정 숫자 찾기, 첫 번째로 10 이상이 되는 인덱스 찾기 탐색 범위를 인덱스 기준으로 절반씩 줄일 수 있는가? 정렬 후 탐색을 해도 문제 조건에 맞는가? (순서가 중요한 경우 제외)2️⃣ Parametric Search 정답이 수치형 범위(최소~최대)로 주어질 수 있는가? 예: 길이, 시간, 비용, 개수, 높이 문제에서 “최대”, “최소” 같은 최적값을 요구하는가? 조건 판별 함수(isPossible)로 “가능/불가능”을 판단할 수 있는가? (중간값을 시도해보고 가능 여부를 검사) 데이터가 정렬되어 있지 않아도 정답 범위 자체를 탐색할 수 있는가? 답이 연속적인 값(숫자)이고, 가능/불가능 경계점이 존재하는가? 예: 높이 15까지 가능, 16부터 불가능 → 경계가 정답 " }, { "title": "[알고리즘] 백트래킹(Backtracking)", "url": "/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9/", "categories": "Coding Test, Algorithm", "tags": "java, algorithm, backtracking", "date": "2025-07-31 02:40:00 +0900", "snippet": "백트래킹(Backtracking)에 대해 공부 후 정리하였습니다. Summary 백트래킹은 완전탐색을 효율적으로 줄이는 기법 DFS + Pruning 구조로 구현 시간복잡도는 최악은 지수적이지만, 가지치기로 충분히 줄어듦 코딩테스트에서 순열, 조합, 스도쿠, N-Queens, 경로 탐색 등에 많이 등장 1️⃣ 백트래킹(Backtracking)의 개념모든 경우의 수를 탐색하는 DFS 기반의 완전 탐색 기법이지만,조건에 맞지 않는 경우는 탐색을 조기에 중단(Pruning, 가지치기) 하여 탐색 공간을 줄이는 방법즉, “해가 될 수 없는 부분은 탐색하지 않고 되돌아감” → 불필요한 탐색을 줄여 효율적으로 문제 해결 가능2️⃣ 특징 완전 탐색 기반 → 최악의 경우 시간 복잡도는 여전히 지수적 하지만 가지치기(Pruning) 로 탐색 공간을 줄여 효율적으로 해결 주로 재귀 함수(DFS)로 구현 대표적으로 순열, 조합, N-Queens, 부분 집합, 그래프 경로 탐색 문제에 사용3️⃣ 시간 복잡도가늠하기 어려움 일반적으로 O(지수 시간, 예: N!), Pruning 정도에 따라 실질적인 시간은 훨씬 줄어듦 N-Queens의 최악은 O(N!), 하지만 Pruning을 잘 하면 더 빠름 부분 집합 탐색: O(2^N)4️⃣ 구현 방법 DFS(재귀)로 상태 공간을 탐색 현재 상태에서 해가 될 수 없는 경우는 가지치기 (return) 가능한 경우에만 다음 단계로 진행 목표 지점까지 도달하면 해(solution) 저장5️⃣ 기본 코드 예시순열 생성 (N개의 수 중 N개 선택)import java.io.*;import java.util.*;public class Main { static int N = 3; static int[] list = {1, 2, 3}; static boolean[] visited = new boolean[N]; static int[] arr = new int[N];\tstatic StringBuilder sb = new StringBuilder();\t\tpublic static void main(String[] args) throws IOException {\t\tfunc(0);\t\tSystem.out.println(sb);\t}\t\tstatic void func(int k) { // 현재 k개까지 수를 택했음\t\tif(index == N) { // N개를 모두 택했으면\t\t\tfor(int i = 0; i &lt; N; i++) {\t\t\t\tsb.append(arr[i]).append(\" \"); // arr에 기록해둔 수를 출력\t\t\t}\t\t\tsb.append('\\n');\t\t\treturn;\t\t}\t\tfor(int i = 0; i &lt; N; i++) { // list안의 N개의 수에 대해\t\t\tif(!visited[i]) { // 아직 list[i]가 사용되지 않았으면 arr[k] = list[i]; // k번째 수를 list[i]로 정함\t\t\t visited[i] = true; // list[i]를 사용되었다고 표시\t\t\t func(k + 1); // 다음 수를 정하러 한 단계 더 들어감\t\t\t visited[i] = false; // k번째 수를 list[i]로 정한 모든 경우에 대해 다 확인했으니 list[i]를 이제 사용되지않았다고 명시\t\t}\t}}N-Queenimport java.util.Scanner;public class Main { static boolean[] isused1 = new boolean[40]; // column 차지 여부 static boolean[] isused2 = new boolean[40]; // / 방향 대각선 차지 여부 static boolean[] isused3 = new boolean[40]; // \\ 방향 대각선 차지 여부 static int cnt = 0; static int n; static void func(int cur) { // cur번째 row에 퀸 배치할 예정 if (cur == n) { // N개 다 배치 성공 cnt++; return; } for (int i = 0; i &lt; n; i++) { // (cur, i)에 퀸 배치 시도 if (isused1[i] || isused2[i + cur] || isused3[cur - i + n - 1]) continue; isused1[i] = true; isused2[i + cur] = true; isused3[cur - i + n - 1] = true; func(cur + 1); isused1[i] = false; isused2[i + cur] = false; isused3[cur - i + n - 1] = false; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); n = sc.nextInt(); func(0); System.out.println(cnt); }}부분수열의 합 부분합을 고르는 것과 동일한 상황 (공집합 제외 2^n - 1개 부분집합 확인)```javaimport java.util.Scanner;public class Main { static int n, s; // 원소 개수 n, 목표 합 s static int[] arr; // 입력 배열 static int cnt = 0; // 조건을 만족하는 부분수열 개수// cur: 현재 탐색 중인 원소의 인덱스// tot: 지금까지 선택한 원소들의 합static void func(int cur, int tot) { // 기저 조건: 배열 끝까지 탐색한 경우 if (cur == n) { if (tot == s) cnt++; // 합이 목표 s라면 개수 증가 return; } // 현재 원소를 선택하지 않는 경우 func(cur + 1, tot); // 현재 원소를 선택하는 경우 func(cur + 1, tot + arr[cur]);}public static void main(String[] args) { Scanner sc = new Scanner(System.in); n = sc.nextInt(); s = sc.nextInt(); arr = new int[n]; for (int i = 0; i &lt; n; i++) { arr[i] = sc.nextInt(); } func(0, 0); // 공집합은 문제 조건에서 제외해야 하므로 s==0이면 1 빼줌 if (s == 0) cnt--; System.out.println(cnt);} } ```6️⃣ 자주 사용하는 곳 순열, 조합, 부분집합 탐색 N-Queens, 스도쿠 그래프 경로 탐색 (Hamiltonian Path, Traveling Salesman Problem) 퍼즐 문제 (예: 미로 찾기, 체스 나이트 투어) 조합 최적화 문제 (Knapsack 변형 등) N이 많이 작은 경우 (백트래킹으로 푸는 문제일 거 같으면 가장 오래걸릴 TC를 직접 돌려보기)" }, { "title": "[알고리즘] 너비 우선 탐색 (BFS), 깊이 우선 탐색 (DFS)", "url": "/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-bfs-dfs/", "categories": "Coding Test, Algorithm", "tags": "java, algorithm, bfs, dfs", "date": "2025-07-31 02:30:00 +0900", "snippet": "너비 우선 탐색(BFS)과 깊이 우선 탐색(DFS)에 대해 공부 후 정리하였습니다. Summary - BFS 그래프나 트리에서 가까운 정점부터 너비를 우선으로 탐색하는 알고리즘 큐(Queue)를 사용하여 구현 문제에 따라 다르지만 그래프의 경우 O(V + E), 2차원 배열의 경우 O(NM) 최단 거리 탐색, 미로 문제, 네트워크 탐색 등에 많이 사용 1. BFS (Breadth-First Search)1️⃣ 개념BFS는 시작 정점에서 가까운 정점부터 너비를 우선으로 차례대로 탐색하는 알고리즘이다. (=다차원 배열에서 각 칸을 방문할 때 너비를 우선으로 방문하는 알고리즘)2️⃣ 특징 레벨 단위 탐색 → 가까운 정점(최단 거리)을 먼저 방문 큐(Queue) 자료구조 사용 (큐에 쌓이는 순서는 반드시 거리 순임) 시작점부터 연결된 다른 모든 점까지의 최단 경로 찾을 수 있어서 최단 거리 문제에서 자주 활용됨 (가중치가 없는 경우) 방문 여부 체크가 반드시 필요3️⃣ 시간 복잡도그래프 BFS (인접리스트) = 모든 정점과 간선을 확인해야 하므로 O(V + E) (정점 수: V, 간선 수: E)2차원 배열 BFS = 격자 크기(N × M), 각 좌표를 최대 한 번씩 방문하므로 O(N × M) (방향 체크는 상수 시간)4️⃣ 구현 방법 시작 칸을 큐에 넣고 방문 처리 큐에서 원소를 꺼내며 인접 정점 확인 방문했었다면 continue, 방문하지 않은 칸이라면 방문했다는 표시를 남기고 큐에 추가 큐가 빌 때까지 2번 과정을 반복 구현 시 주의할 부분 시작점에 방문 표시했는지 확인하기 큐에서 넣을 때 방문했다믄 표시하기 (큐에서 뺄 때 방문 표시X) 이웃한 원소의 범위 확인하기 5️⃣ 예시 코드그래프의 BFS (인접리스트)import java.util.*;public class BFSExample { static int n = 6; // 정점의 수 static List&lt;List&lt;Integer&gt;&gt; graph = new ArrayList&lt;&gt;(); static boolean[] visited = new boolean[n + 1]; // 정점 번호가 1부터 시작한다고 가정 public static void main(String[] args) { // 그래프 초기화 for (int i = 0; i &lt;= n; i++) { graph.add(new ArrayList&lt;&gt;()); } // 예시 간선 추가 (무방향 그래프) addEdge(1, 2); addEdge(1, 3); addEdge(2, 4); addEdge(2, 5); addEdge(3, 6); // BFS 시작 (1번 정점에서 시작) bfs(1); } // 간선 추가 함수 static void addEdge(int u, int v) { graph.get(u).add(v); graph.get(v).add(u); // 무방향 그래프일 경우만 필요 } // BFS 구현 static void bfs(int start) { Deque&lt;Integer&gt; queue = new ArrayDeque&lt;&gt;(); visited[start] = true; queue.offer(start); // 시작 노드 큐에 추가 while (!queue.isEmpty()) { int current = queue.poll(); // 큐에서 하나 꺼냄 System.out.print(current + \" \"); // 현재 노드의 인접 노드 탐색 for (int next : graph.get(current)) { if (!visited[next]) { visited[next] = true; // 방문 처리 queue.offer(next); // 다음 노드를 큐에 추가 } } } }}2차원 배열의 BFS 예제 상하좌우 네 방향으로 이동 가능 0은 이동 가능, 1은 이동 불가 코드 설명 int[][] map : 2차원 배열 int[][] dist : 시작 지점으로부터 각 지점까지의 거리 boolean[][] visited : 방문 여부 int[] dx, dy : 방향 벡터 (상하좌우) import java.util.*;public class BFS2D { static int N = 5; static int M = 6; // 미로 (0: 이동 가능, 1: 벽) static int[][] map = { {0, 1, 0, 0, 0, 0}, {0, 1, 0, 1, 1, 0}, {0, 0, 0, 1, 0, 0}, {1, 1, 0, 0, 0, 1}, {0, 0, 0, 1, 0, 0} }; static int[][] dist = new int[N][M]; // 거리 저장 static boolean[][] visited = new boolean[N][M]; // 상, 하, 좌, 우 static int[] dx = {-1, 1, 0, 0}; static int[] dy = {0, 0, -1, 1}; public static void main(String[] args) { bfs(0, 0); // (0, 0)부터 시작 System.out.println(\"도착지까지 거리: \" + dist[N - 1][M - 1]); // 도착 좌표까지 거리 출력 } static void bfs(int x, int y) { Deque&lt;int[]&gt; queue = new ArrayDeque&lt;&gt;(); visited[x][y] = true; dist[x][y] = 1; // 시작 지점 거리 1로 설정 queue.offer(new int[]{x, y}); while (!queue.isEmpty()) { int[] current = queue.poll(); int cx = current[0]; int cy = current[1]; for (int d = 0; d &lt; 4; d++) { int nx = cx + dx[d]; int ny = cy + dy[d]; // 범위 체크 + 벽이 아님 + 미방문일 때 if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &lt; M) { if (!visited[nx][ny] &amp;&amp; map[nx][ny] == 0) { visited[nx][ny] = true; dist[nx][ny] = dist[cx][cy] + 1; queue.offer(new int[]{nx, ny}); } } } } }}6️⃣ 자주 사용하는 곳 최단 거리 탐색 (가중치가 없는 그래프) 미로 탐색 문제 네트워크 연결 여부 확인 Flood Fill (영역 채우기 문제) SNS/웹 크롤링 (친구 관계, 링크 탐색) 문제 구현 예시 BOJ 1926번 : 띄엄띄엄 덩어리 찾으려면 이중 for문으로 시작점 찾아서 BFS 진행하기 - O(NM) BOJ 2178번 : 다차원 배열에서의 거리 측정은 -1로 채워진 다차원 int배열에 거리 저장하기 (+1씩, -1이 아니라면 방문한 칸임을 확인할 수 있음) BOJ 7576번 : 시작점이 여러 개일 때, 모든 시작점들을 큐에 넣어두고 BFS 진행하기 BOJ 4179번 : 시작점이 두 종류일 때, 불 BFS를 진행해서 각 칸에 전파되는 시간 구한 후 사람 탈출 BFS를 진행하는데 시간 조건 확인하기 (단방향 영향, 불만 사람에게 영향 줌) BOJ 18809번 : 시작점이 두 종류인데 양방향 영향일 때, 백트래킹 이용해서 시간 순으로 동시 진행 필요 (양방향 영향, 불과 물이 만나면 상호작용) BOJ 1697번 : 1차원에서의 BFS는 조건인 이동 방법이 상하좌우 대신이라고 생각하기 + 움직이는 범위 잘 확인하기 Summary - DFS 그래프나 트리에서 가까운 정점부터 깊이를 우선으로 탐색하는 알고리즘 재귀나 스택을 이용하여 구현 그래프를 인접리스트로 구현한 경우 O(V + E), 인접행렬의 경우 O(V^2) 그래프 탐색, 경로 찾기, 사이클 탐지, 백트래킹 등에 많이 사용 2. DFS (Depth-First Search)1️⃣ 개념DFS는 시작 노드에서 한 경로를 따라 끝까지 탐색한 후, 더 이상 진행할 수 없으면 이전 분기점으로 돌아가 다른 경로를 탐색하는 알고리즘이다. (=다차원 배열에서 각 칸을 방문할 때 깊이를 우선으로 방문하는 알고리즘)2️⃣ 특징 재귀 함수 또는 스택(Stack)으로 구현 가능 (BFS에서 스택으로 바뀌면 DFS와 동일) 모든 노드를 빠짐없이 방문 가능 경로의 깊이를 우선적으로 탐색하기 때문에 백트래킹과 잘 어울림 거리를 구할 수 없어서 다차원 배열에서 사용을 잘 안함 (그래프, 트리에서 사용할 수 있음)3️⃣ 시간 복잡도 그래프를 인접리스트로 구현 시 O(V + E) (정점 수: V, 간선 수: E) 그래프를 인접 행렬로 구현하면 O(V^2)4️⃣ 구현 방법 시작 노드를 스택에 넣고 방문 처리 스택에서 원소를 꺼내 연결된 노드 중 방문하지 않았다면, 방문 처리 후 스택에 삽입 스택이 빌 때까지 2번 과정 반복5️⃣ 예시 코드재귀로 구현import java.util.*;public class DFSExample { static int n = 6; // 정점의 수 static List&lt;List&lt;Integer&gt;&gt; graph = new ArrayList&lt;&gt;(); static boolean[] visited = new boolean[n + 1]; // 정점 번호가 1부터 시작한다고 가정 public static void main(String[] args) { // 그래프 초기화 for (int i = 0; i &lt;= n; i++) { graph.add(new ArrayList&lt;&gt;()); } // 예시 간선 추가 (무방향 그래프) addEdge(1, 2); addEdge(1, 3); addEdge(2, 4); addEdge(2, 5); addEdge(3, 6); // DFS 시작 (1번 정점에서 시작) dfs(1); } // 간선 추가 함수 static void addEdge(int u, int v) { graph.get(u).add(v); graph.get(v).add(u); // 무방향 그래프일 경우 } // DFS 재귀 함수 static void dfs(int current) { visited[current] = true; // 현재 노드 방문 처리 System.out.print(current + \" \"); // 현재 노드의 인접 노드 순회 for (int next : graph.get(current)) { if (!visited[next]) { dfs(next); // 아직 방문하지 않은 노드라면 재귀 호출 } } }}스택으로 구현import java.util.*;public class DFSStackExample { static int n = 6; // 정점의 수 static List&lt;List&lt;Integer&gt;&gt; graph = new ArrayList&lt;&gt;(); static boolean[] visited = new boolean[n + 1]; public static void main(String[] args) { // 그래프 초기화 for (int i = 0; i &lt;= n; i++) { graph.add(new ArrayList&lt;&gt;()); } // 예시 간선 추가 (무방향 그래프) addEdge(1, 2); addEdge(1, 3); addEdge(2, 4); addEdge(2, 5); addEdge(3, 6); // DFS 시작 (1번 정점에서 시작) dfsStack(1); } // 간선 추가 함수 static void addEdge(int u, int v) { graph.get(u).add(v); graph.get(v).add(u); // 무방향 그래프 } // 스택을 이용한 DFS 함수 static void dfsStack(int start) { Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); stack.push(start); while (!stack.isEmpty()) { int current = stack.pop(); if (!visited[current]) { visited[current] = true; System.out.print(current + \" \"); // 인접 노드를 스택에 추가 (작은 번호 먼저 방문하려면 정렬 필요) // 기본적으로는 큰 번호부터 넣어야 작은 번호가 먼저 나옴 List&lt;Integer&gt; neighbors = graph.get(current); Collections.sort(neighbors, Collections.reverseOrder()); for (int next : neighbors) { if (!visited[next]) { stack.push(next); } } } } }}6️⃣ 자주 사용하는 곳 그래프 탐색 (연결 요소 개수 구하기) 경로 찾기 (특정 노드까지 도달 가능한지 확인) 사이클 탐지 백트래킹 기반 문제 (순열, 조합, 부분 집합, 미로 탐색 등)3. 전체 요약 정리 항목 DFS BFS 구현 방식 재귀 / 스택 큐 방문 순서 깊이 우선 너비 우선 자료 구조 Stack (재귀 호출 시 call stack 사용) Queue 시간 복잡도 O(V + E) O(V + E), O(NM) 용도 예시 미로 경로 찾기, 백트래킹 최단 경로 탐색 " }, { "title": "[알고리즘] 재귀 (Recursion)", "url": "/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%9E%AC%EA%B7%80/", "categories": "Coding Test, Algorithm", "tags": "java, algorithm, recursion", "date": "2025-07-30 02:40:00 +0900", "snippet": "재귀에 대해 공부 후 정리하였습니다. Summary 함수가 자기 자신을 호출하는 방식으로 문제를 해결하는 기법 종료 조건(기저 조건)이 반드시 필요하며, 함수 호출 스택을 사용 문제에 따라 다르지만 보통 O(분기^깊이) 분할정복, 백트래킹, DFS/BFS, 수학적 정의(팩토리얼, 피보나치 등) 등에 많이 사용 수학적 귀납법 public static void func(int n) { if (n == 0) return; System.out.println(n); func(n - 1);} 절차지향적 사고(코드가 동작하는 순서대로 생각)를 버려야 재귀를 이해할 수 있음 귀납적 사고 func(1)이 1을 출력한다. func(k)가 k k-1 k-2 … 1을 출력하면 func(k+1)은 k+1 k k-1 k-2 … 1을 출력한다. (k+1 출력 후 func(k)을 호출하기 때문) 두 문장이 참이므로 귀납적으로 func()이 n~1까지 차례로 출력하는 함수임을 알 수 있음 1️⃣ 개념재귀는 함수가 자기 자신을 직접 혹은 간접적으로 호출하는 프로그래밍 기법이다. 복잡한 문제를 동일한 형태의 더 작은 문제로 나누어 해결한다.2️⃣ 특징 기저 조건(Base Case): 무한 호출을 막기 위해 종료 조건 반드시 필요 스택(Stack) 메모리를 사용하여 함수 호출을 저장 모든 재귀 함수는 반복문만으로 동일한 동작하는 함수 만들 수 있음 재귀는 반복문 구현에 비해 코드가 간결하나, 메모리/시간에서는 손해임 한 함수가 자기 자신을 여러 번 호출하게 되면 비효율적일 수 있음 (동일한 계산을 여러번 반복)3️⃣ 시간 복잡도재귀 함수의 시간 복잡도는 호출 횟수 × 각 호출의 처리 시간으로 계산됨 피보나치 수열 단순 재귀 → O(2^N) 팩토리얼, DFS → O(N) 분할 정복(이분 탐색, 병합 정렬) → O(N log N)4️⃣ 구현 방법 (ex. 하노이 탑) 함수의 인자로 어떤 것을 받고 어디까지 계산 후 자신에게 넘겨줄지 명확하게 정해야 함 반드시 특정 입력에 대해서는 자기 자신을 호출하지 않고 종료되어야 함 모든 입력은 기저 조건으로 수렴해야 함 함수의 정의 void func(int a, int b, int n) : 원판 n개를 a번 기둥에서 b번 기둥으로 옮기는 방법을 출력하는 함수 기저 조건 정의 (Base Case) - 지극히 자명한, 계산 없이도 바로 결과를 알 수 있는 경우로 설정 n = 1일 때, a에서 b로 옮기도록 하기 재귀식 작성 기둥 번호의 합이 6이므로, a or b가 아닌 번호는 6-a-b번임 n-1개의 원판을 기둥 a에서 기둥 6-a-b로 옮긴다. =&gt; func(a, 6-a-b, n-1) n번 원판을 기둥 a에서 기둥 b로 옮긴다. =&gt; a b 출력 n-1개의 원판을 기둥 6-a-b에서 기둥 b로 옮긴다. =&gt; func(6-a-b, b, n-1) 5️⃣ 예시 코드팩토리얼public class RecursionExample { // 팩토리얼: n! = n * (n-1)! public static int factorial(int n) { if (n == 0) return 1; // 기저 조건 return n * factorial(n - 1); // 재귀 호출 } public static void main(String[] args) { System.out.println(factorial(5)); // 출력: 120 }}피보나치 수열public class RecursionExample { // 피보나치: F(n) = F(n-1) + F(n-2) public static int fibonacci(int n) { if (n == 0) return 0; // 기저 조건 if (n == 1) return 1; return fibonacci(n - 1) + fibonacci(n - 2); // 재귀 호출 } public static void main(String[] args) { System.out.println(fibonacci(6)); // 출력: 8 }}6️⃣ 자주 사용하는 곳 수학적 정의: 팩토리얼, 피보나치, 최대공약수(GCD) 탐색 알고리즘: DFS(깊이 우선 탐색), 백트래킹(순열/조합/부분집합) 분할 정복: 병합 정렬, 퀵 정렬, 이분 탐색 트리/그래프 탐색: 트리 순회(전위/중위/후위), 그래프 탐색" }, { "title": "[알고리즘] 순열, 조합, 부분 집합", "url": "/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%88%9C%EC%97%B4%EC%A1%B0%ED%95%A9/", "categories": "Coding Test, Algorithm", "tags": "java, algorithm", "date": "2025-07-30 02:30:00 +0900", "snippet": "순열, 조합, 부분 집합에 대해 공부 후 정리하였습니다.1. 순열 (Permutation) 설명: 서로 다른 n개 중에서 r개를 순서 있게 뽑는 경우 시간 복잡도: O(n!)public class Permutation { static int n = 3; static int r = 3; static int[] arr = {1, 2, 3}; static boolean[] visited = new boolean[n]; static int[] output = new int[r]; public static void main(String[] args) { perm(0); } // 순열 생성 함수 static void perm(int depth) { if (depth == r) { print(output); return; } for (int i = 0; i &lt; n; i++) { if (!visited[i]) { visited[i] = true; output[depth] = arr[i]; perm(depth + 1); visited[i] = false; } } } static void print(int[] out) { for (int i : out) System.out.print(i + \" \"); System.out.println(); }}2. 중복 순열 (Permutation with Repetition) 설명: 서로 다른 n개 중에서 중복을 허용하여 r개를 순서 있게 뽑는 경우 시간 복잡도: O(n^r)public class RepeatedPermutation { static int n = 3; static int r = 2; static int[] arr = {1, 2, 3}; static int[] output = new int[r]; public static void main(String[] args) { permRep(0); } // 중복 순열 생성 함수 static void permRep(int depth) { if (depth == r) { print(output); return; } for (int i = 0; i &lt; n; i++) { output[depth] = arr[i]; permRep(depth + 1); } } static void print(int[] out) { for (int i : out) System.out.print(i + \" \"); System.out.println(); }}3. 조합 (Combination) 설명: 서로 다른 n개 중에서 r개를 순서 없이 뽑는 경우 시간 복잡도: O(nCr)public class Combination { static int n = 4; static int r = 2; static int[] arr = {1, 2, 3, 4}; static int[] output = new int[r]; public static void main(String[] args) { comb(0, 0); } // 조합 생성 함수 static void comb(int depth, int start) { if (depth == r) { print(output); return; } for (int i = start; i &lt; n; i++) { output[depth] = arr[i]; comb(depth + 1, i + 1); } } static void print(int[] out) { for (int i : out) System.out.print(i + \" \"); System.out.println(); }}4. 중복 조합 (Combination with Repetition) 설명: 서로 다른 n개 중에서 중복을 허용하여 r개를 뽑는 경우 시간 복잡도: O(nHr) = O((n+r-1)Cr)public class RepeatedCombination { static int n = 3; static int r = 2; static int[] arr = {1, 2, 3}; static int[] output = new int[r]; public static void main(String[] args) { combRep(0, 0); } // 중복 조합 생성 함수 static void combRep(int depth, int start) { if (depth == r) { print(output); return; } for (int i = start; i &lt; n; i++) { output[depth] = arr[i]; combRep(depth + 1, i); // i부터 시작 (중복 허용) } } static void print(int[] out) { for (int i : out) System.out.print(i + \" \"); System.out.println(); }}5. 부분 집합 (Subset) 설명: n개의 원소로 만들 수 있는 모든 부분 집합을 구함 총 경우의 수: 2ⁿ 시간 복잡도: O(2^n)public class Subset { static int n = 3; static int[] arr = {1, 2, 3}; static boolean[] selected = new boolean[n]; public static void main(String[] args) { subset(0); } // 부분 집합 생성 함수 static void subset(int depth) { if (depth == n) { printSubset(); return; } // 현재 원소 포함 selected[depth] = true; subset(depth + 1); // 현재 원소 미포함 selected[depth] = false; subset(depth + 1); } static void printSubset() { System.out.print(\"{ \"); for (int i = 0; i &lt; n; i++) { if (selected[i]) System.out.print(arr[i] + \" \"); } System.out.println(\"}\"); }}" }, { "title": "[알고리즘] 완전 탐색 : 브루트 포스 (Brute Force)", "url": "/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B8%8C%EB%A3%A8%ED%8A%B8%ED%8F%AC%EC%8A%A4/", "categories": "Coding Test, Algorithm", "tags": "java, algorithm, bruteforce", "date": "2025-07-29 02:30:00 +0900", "snippet": "완전 탐색 중 Brute Force 알고리즘에 대해 정리하였습니다.1. 완전 탐색 (Exhaustive Search)모든 가능한 경우의 수를 탐색하여 최적의 결과를 찾는 방법입니다. 모든 가능성을 고려하므로 항상 최적의 해를 찾을 수 있지만, 경우의 수가 많은 경우 시간과 메모리의 부담이 커질 수 있습니다.완전 탐색의 종류 브루트 포스 순열 백트래킹 비트마스킹 DFS / BFS2. 브루트 포스 (Brute Force)말 그대로 “무식하게 힘으로 밀어붙이는 방식”의 알고리즘입니다. 가능한 모든 경우의 수를 탐색하여 정답을 찾는 방식입니다. 해당 알고리즘은 경우의 수가 작을 때 사용하는 것이 일반적입니다. ex) 비밀번호가 000~999까지라고 할 때, 모든 숫자를 다 시도해서 맞추는 것 → 브루트 포스시간 복잡도가능한 모든 경우의 수에 따라 결정됩니다. 보통 O(n^k) 또는 O(k!) 으로 비효율적인 경우가 많습니다.장점 설계하고 구현하기 쉬움 정확한 결과 보장단점 가능한 경우의 수가 커질 경우, 시간이 매우 오래 걸릴 수 있음 메모리의 효율면에서 매우 비효율적사용 조건 사용 시기 설명 N이 작고 경우의 수가 적을 때 일반적으로 N ≤ 10~15 문제의 조건이 복잡하지 않고 단순 비교로 해결 가능할 때 부분합, 조합 확인 등 빠른 구현이 필요하고, 최적화는 중요하지 않을 때 대회 초반 문제 등 정답을 무조건 찾아야 하고 최적화는 부차적일 때 패스워드, 수열 맞추기 문제 등 사용 예시1. 반복문을 사용하는 경우 두 수의 합이 K인 쌍 찾기 (배열 내 모든 쌍 확인)for (int i = 0; i &lt; n; i++) { for (int j = i + 1; j &lt; n; j++) { if (arr[i] + arr[j] == K) { System.out.println(arr[i] + \", \" + arr[j]); } }}2. 재귀를 사용하는 경우 팩토리얼 계산public class Main { public static void main(String[] args) { System.out.println(factorial(5)); // 5! = 5 * 4 * 3 * 2 * 1 = 120 } public static int factorial(int n) { if (n == 0) { // base case return 1; } else { // recursion return n * factorial(n - 1); } }} 재귀 함수 (Rebursion Function) 함수 내부에서 ‘자기 자신을 호출’하는 함수를 의미 함수가 자신을 반복적으로 호출하면서 원하는 결과를 도출할 수 있음 단, 함수 호출이 계속해서 쌓이기 때문에 호출 스택이 많아져서 성능이 저하될 수 있음 주의할 점 재귀문을 종료시키기 위한 종료 조건이 반드시 필요 현재 함수의 상태를 저장하는 parameter(인자)가 필요 return문 신경 쓰기 참고 블로그 Contributor9 - 완전 탐색 이해하기 SpearDragon - 브루트포스 알고리즘 " }, { "title": "[코딩테스트] Java 정리 - 2 (2)", "url": "/posts/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%9E%90%EB%B0%94-%EC%A0%95%EB%A6%AC2-2/", "categories": "Coding Test, Study", "tags": "java", "date": "2025-07-27 02:30:00 +0900", "snippet": "코딩테스트에서 자주 사용되는 Java 자료구조 등을 정리했습니다. 컬렉션 프레임워크는 다양한 자료구조를 직접 구현하지 않고, 쉽게 사용할 수 있도록 제공해줍니다.D. Set 인터페이스중복 X, 순서 X연관 메서드 메서드 설명 add(E e) 요소 추가, 이미 존재하면 false 반환 remove(Object o) 해당 요소 제거 contains(Object o) 해당 요소가 존재하는지 확인 isEmpty() 비어 있는지 확인 size() 집합 크기 반환 clear() 모든 요소 제거 iterator() 순회용 Iterator 반환 (for-each 사용 가능) 시간 복잡도 연산 HashSet 평균 LinkedHashSet TreeSet add O(1) O(1) O(log n) remove O(1) O(1) O(log n) contains O(1) O(1) O(log n) 중복 제거 + 빠른 속도 : HashSet 중복 제거 + 순서 유지 : LinkedHashSet 중복 제거 + 정렬 : TreeSet6. HashSet 클래스요소의 중복을 허용하지 않고 (equals()와 hashCode()로 중복 여부 판단), 순서를 보장하지 않습니다. 가장 빠른 검색/삽입/삭제 성능을 가집니다. (평균 O(1), 최악 O(n) - hashCode() 충돌이 많이 날 때) 내부적으로 HashMap을 사용합니다.기본 사용 예시Set&lt;String&gt; set = new HashSet&lt;&gt;();set.add(\"apple\");set.add(\"banana\");set.add(\"apple\"); // 중복, 추가되지 않음System.out.println(set); // [banana, apple] (순서 보장 X)7. LinkedHashSet 클래스HashSet과 동일하지만, 입력 순서를 유지하는 자료구조입니다. 추가된 순서 또는 가장 최근에 접근한 순서대로 접근 가능합니다. 내부적으로 HashMap와 이중 연결 리스트로 구성되어 있습니다.기본 사용 예시Set&lt;String&gt; set = new LinkedHashSet&lt;&gt;();set.add(\"apple\");set.add(\"banana\");set.add(\"cherry\");System.out.println(set); // [apple, banana, cherry]8. TreeSet 클래스중복을 허용하지 않고 순서를 가지지 않지만, 데이터를 정렬된 상태로 저장합니다. 기본적으로 오름차순 정렬이고, Comparable 또는 Comparator 구현으로 커스터마이징 가능합니다. 내부적으로 Red-Black Tree(이진 균형 트리)를 사용합니다.기본 사용 예시Set&lt;Integer&gt; set = new TreeSet&lt;&gt;();set.add(30);set.add(10);set.add(20);System.out.println(set); // [10, 20, 30]정렬 기준 커스터마이징Set&lt;String&gt; set = new TreeSet&lt;&gt;(Comparator.reverseOrder());set.add(\"apple\");set.add(\"banana\");set.add(\"cherry\");System.out.println(set); // [cherry, banana, apple]E. Map 인터페이스key-value 쌍 저장(key 고유), 순서 X연관 메서드 메서드 설명 put(K key, V value) key-value 추가 putAll(Map t) 지정된 Map의 모든 쌍 추가 get(Object key) key로 value 조회 containsKey(Object key) key 존재 여부 containsValue(Object value) value 존재 여부 remove(Object key) 해당 key 제거 keySet() key 집합 반환 (Set) values() 모든 value 반환 (Collection) entrySet() key-value 쌍 Map.Entry타입의 객체로 저장한 Set을 반환 size() 요소 개수 반환 clear() 전체 요소 삭제 equals(Object o) 동일한 Map인지 비교 isEmpty() Map이 비어있는지 확인 hashCode() 해시코드 반환 시간 복잡도 연산 HashMap LinkedHashMap TreeMap 삽입 O(1) O(1) O(log n) 검색 O(1) O(1) O(log n) 삭제 O(1) O(1) O(log n) Map.Entry 인터페이스 Map.Entry는 Map 내부에 정의된 중첩(static) 인터페이스입니다. 하나의 key-value 쌍을 표현합니다. 일반적으로 Map을 순회할 때 가장 유용한 방식입니다. Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();map.put(\"apple\", 3);map.put(\"banana\", 5);// Entry 사용for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) { System.out.println(\"key: \" + entry.getKey() + \", value: \" + entry.getValue());}// 빈도 기준 정렬 (내립차순)List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; sortedList = new ArrayList&lt;&gt;(freqMap.entrySet());sortedList.sort((a, b) -&gt; b.getValue() - a.getValue()); 메서드 설명 K getKey() key 반환 V getValue() value 반환 V setValue(V value) value 변경 (일반적으로 사용 지양) boolean equals(Object o) 두 Entry가 같은지 비교 int hashCode() Entry의 해시값 반환 9. HashMap 클래스Hashtable을 보완한 컬렉션으로 비순서 해시 기반 맵입니다. key는 중복 불가하고 value는 중복이 가능하며, key/value에 null이 허용됩니다. 순서를 보장하지 않습니다. 가장 일반적이고, 빠른 성능을 보입니다.기본 사용 예시Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();map.put(\"apple\", 3);map.put(\"banana\", 5);System.out.println(map.get(\"apple\")); // 3// key값들을 set으로 반환 및 순회for(String key : map.keySet()) {    System.out.println(key + \" =&gt; \" + map.get(key));}10. LinkedHashMap 클래스HashMap을 상속하므로 흡사하지만, Entry들이 연결 리스트를 구성하여 데이터의 순서를 보장합니다. 삽입된 순서대로 순서를 가집니다.기본 사용 예시Map&lt;String, String&gt; lhm = new LinkedHashMap&lt;&gt;();lhm.put(\"first\", \"a\");lhm.put(\"second\", \"b\");System.out.println(lhm); // {first=a, second=b}for(Integer key : lhm.keySet()) { System.out.println(key + \" =&gt; \" + lhm.get(key));}11. TreeMap 클래스SortedMap 인터페이스를 구현하고 있어 Key 값을 기준으로 정렬됩니다. 정렬된 순서로 저장하므로 빠른 검색(특히 범위 검색)이 가능합니다. 단, 키와 값을 저장하는 동시에 정렬하므로 저장 시간이 다소 오래 걸립니다. 정렬되는 순서는 숫자 → 알파벳 대문자 → 알파벳 소문자 → 한글 순이며, 기본적으로 오름차순입니다. key에 null은 불가능하고, TreeSet과 같은 원리입니다.기본 사용 예시Map&lt;String, Integer&gt; tm = new TreeMap&lt;&gt;();tm.put(\"c\", 1);tm.put(\"a\", 2);System.out.println(tm); // {a=2, c=1}for(Integer key : tm.keySet()) { System.out.println(key + \" =&gt; \" + tm.get(key));} 참고 블로그 Inpa Dev - Collections Framework 총정리 " }, { "title": "[Java] 지료형 변환과 Stream 문법", "url": "/posts/%EC%9E%90%EB%B0%94-%EA%B3%B5%EB%B6%804/", "categories": "Coding Test, Study", "tags": "java", "date": "2025-07-26 02:30:00 +0900", "snippet": "코딩테스트 문제를 풀다가 자료형 변환하는 방법 중 stream에 대해 정리하게 되었습니다.1️⃣ Stream이란? Java 8부터 도입된 기능 배열이나 리스트 같은 데이터들을 선언형(데이터 중심 방식)으로 처리 for나 if 없이 .map(), .filter(), .collect() 등을 사용해 가공 가능 자주 쓰는 Stream 메서드 메서드 설명 filter() 조건에 맞는 요소만 남김 map() 각 요소를 변형함 mapToInt() 요소를 int로 변환 boxed() primitive → 객체형 (예: int → Integer) collect() 최종 결과를 리스트 등으로 수집 forEach() 요소 하나씩 반복 수행 sorted() 정렬 distinct() 중복 제거 2️⃣ 자료형 변환 예시Integer[] → int[]Integer[] boxedArray = {1, 2, 3, 4};int[] unboxedArray = Arrays.stream(boxedArray) .mapToInt(Integer::intValue) .toArray();int[] → Integer[]int[] primitiveArray = {1, 2, 3, 4};Integer[] boxedArray = Arrays.stream(primitiveArray) .boxed() .toArray(Integer[]::new);List → int[]List&lt;Integer&gt; list = Arrays.asList(1, 2, 3);int[] arr = list.stream() .mapToInt(Integer::intValue) // i -&gt; i.intValue() 축약 표현 .toArray();int[] arr2 = list.stream() .mapToInt(i -&gt; i) // 내부적으로 unboxing 자동 수행 .toArray();// 반복문 사용int[] arr1 = new int[list.size()]for (int i = 0; i &lt; list.size(); i++) arr1[i] = list.get(i).intValue();int[] → Listint[] arr = {1, 2, 3};List&lt;Integer&gt; list = Arrays.stream(arr) .boxed() .collect(Collectors.toList());String → ListString str = \"hello\";List&lt;Character&gt; charList = str.chars() .mapToObj(c -&gt; (char) c) .collect(Collectors.toList());String → ListString str = \"a,b,c\";List&lt;String&gt; list = Arrays.stream(str.split(\",\")) .collect(Collectors.toList());String → Character[]String str = \"abcdefg\";Character[] charArr = str.chars() .mapToObj(c -&gt; (char) c) .toArray(Character[]::new);System.out.println(Arrays.toString(charArr)); // [a, b, c, d, e, f, g]String → String[]String str = \"a,b,c,d,e,f,g\";String[] strArr = str.chars() .filter(c -&gt; c != ',') .mapToObj(c -&gt; String.valueOf((char) c)) .toArray(String[]::new);System.out.println(Arrays.toString(strArr)); // [a, b, c, d, e, f, g]String[] → StringString[] arr = {\"a\", \"b\", \"c\"};String result = String.join(\",\", arr); // \"a,b,c\"String result = Arrays.stream(arr) .collect(Collectors.joining(\",\"));3️⃣ 기타 활용법문자열 안에서 숫자만 추출하기String s = \"a1b2c3\";List&lt;Integer&gt; digits = s.chars() .filter(Character::isDigit) .map(c -&gt; c - '0') .boxed() .collect(Collectors.toList());" }, { "title": "[Java] 문자열을 배열로 변환하는 방법", "url": "/posts/%EC%9E%90%EB%B0%94-%EA%B3%B5%EB%B6%803/", "categories": "Coding Test, Study", "tags": "java", "date": "2025-07-25 02:30:00 +0900", "snippet": "코딩테스트 문제를 풀다가 String을 배열로 변환하는 방법에 대해 공부 중 정리하게 되었습니다.1️⃣ 구분자 없는 문자열1. split() - String[] 반환String s = \"hello\";String[] arr = s.split(\"\");System.out.println(Arrays.toString(arr)); // [h, e, l, l, o] 문자열 각각을 문자열로 나눔 (String[]) 성능 : 느림, 내부에서 정규식 사용2. toCharArray() - char[] 반환String s = \"hello\";char[] arr = s.toCharArray();System.out.println(Arrays.toString(arr)); // [h, e, l, l, o] 문자열을 문자 배열로 변환 단점: char[]로 나오기 때문에 String 메서드를 바로 못 씀 성능 : 가장 빠름, 정규식 없음, 내부적으로 배열 복사3. 반복문 - char[] 등 반환String s = \"hello\";char[] arr = new char[s.length()];for (int i = 0; i &lt; s.length(); i++) { arr[i] = s.charAt(i);}System.out.println(Arrays.toString(arr)); // [h, e, l, l, o] 가장 유연함, 원하는 자료형으로 직접 조작 가능 char[] 외에도 int[], List 등으로 변환 가능 성능 : 빠름2️⃣ 구분자 있는 문자열1. split() - String[] 반환String s = \"apple,banana,orange\";String[] arr = s.split(\",\");System.out.println(Arrays.toString(arr)); // [apple, banana, orange] 특정 구분자 기준으로 나눔 정규식 기반이라 복잡한 구분자 처리 가능하지만 느릴 수 있음 성능 : 저하 가능성2. StringTokenizer - String[] 반환import java.util.*;String s = \"apple,banana,orange\";StringTokenizer st = new StringTokenizer(s, \",\");String[] arr = new String[st.countTokens()];int i = 0;while (st.hasMoreTokens()) { arr[i++] = st.nextToken();}System.out.println(Arrays.toString(arr)); // [apple, banana, orange] 정규식 없이 가볍고 빠름 오래된 방식, 비추천3️⃣ 전체 내용 정리 구분 방법 리턴 성능 특징 구분자 X split(\"\") String[] 중 느림 (정규식) 구분자 X toCharArray() char[] 빠름 빠르고 정규식 없음 구분자 X 반복문 (charAt) char[] 등 빠름 유연, 고성능 구분자 O split(\",\") String[] 중 정규식으로 유연하지만 느림 구분자 O StringTokenizer 토큰 객체 빠름 경량화, 직접 파싱 필요, 구식 4️⃣ 참고List를 배열로 변환할 때 toArray() 사용List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(\"a\");list.add(\"b\");list.add(\"c\");// 1. 배열 선언과 동시에 할당String[] arr = list.toArray(new String[0]); // [\"a\", \"b\", \"c\"]// 2. 배열 선언 후 값 할당String[] arr2 = new String[list.size()];list.toArray(arr2); // [\"a\", \"b\", \"c\"]" }, { "title": "[Java] 배열 복사 메서드 비교", "url": "/posts/%EC%9E%90%EB%B0%94-%EA%B3%B5%EB%B6%802/", "categories": "Coding Test, Study", "tags": "java", "date": "2025-07-24 02:30:00 +0900", "snippet": "코딩테스트 문제를 풀다가 부분 배열 반환에 대해 공부 중 정리하게 되었습니다.1️⃣ Arrays.copyOf() Arrays.copyOf(복사할 배열, 길이)int[] original = {1, 2, 3};int[] copy = Arrays.copyOf(original, 5); 기능 : 배열을 지정한 길이만큼 복사 특징 원본보다 길이가 크면 남는 자리는 0으로 채워짐 copy.length를 지정함 시간 복잡도 : O(n) (복사할 길이 n) 내부 구현 : System.arraycopy() 사용2️⃣ Arrays.copyOfRange() Arrays.copyOfRange(복사할 배열, from, to)int[] original = {1, 2, 3, 4, 5};int[] copy = Arrays.copyOfRange(original, 1, 4); // [2, 3, 4] 기능 : from 인덱스부터 to-1 인덱스까지 복사 특징 원본보다 to 인덱스가 크면 남는 자리는 배열의 타입 기본값으로 채워짐 시간 복잡도 : O(to - from) 내부 구현 : System.arraycopy() 사용3️⃣ System.arraycopy() System.arraycopy(복사할 배열, 복사 시작 idx, 대상 배열, 대상 시작 idx, 복사할 길이)int[] original = {1, 2, 3, 4, 5};int[] dest = new int[3];System.arraycopy(original, 1, dest, 0, 3); // [2, 3, 4] 기능 : 배열의 원하는 범위를 다른 배열에 직접 복사 특징 가장 빠름 (대용량 복사 시 유리) 대상 배열을 직접 만들어야 함 시간 복잡도 : O(n) 내부 구현 : JVM 내부 native 코드 사용4️⃣ 전체 비교 정리 메서드 목적 복사 범위 대상 배열 자동 생성 남는 공간 처리 속도 Arrays.copyOf() 길이 기반 복사 0 ~ newLength O 0으로 채움 보통 Arrays.copyOfRange() 범위 기반 복사 [from, to) O 0으로 채움 보통 System.arraycopy() 수동 복사 지정된 srcPos~srcPos+length ✕ (new로 직접 생성) N/A 가장 빠름 " }, { "title": "[Java] List와 ArrayList 차이", "url": "/posts/%EC%9E%90%EB%B0%94-%EA%B3%B5%EB%B6%801/", "categories": "Coding Test, Study", "tags": "java", "date": "2025-07-22 02:30:00 +0900", "snippet": "자료구조를 공부하다가 리스트 선언에 대한 의문을 가지고 정리하게 되었습니다.1️⃣ List vs ArrayList List : 인터페이스 ArrayList, LinkedList, Vector 등 여러 구현체(클래스)의 공통 규약을 정의합니다. add(), get(), remove() 같은 메서드가 정의되어 있지만 구현은 없습니다. ArrayList : List 인터페이스를 구현한 클래스 내부적으로는 배열로 요소를 관리하며, 요소를 순차적으로 저장합니다. 인덱스로 빠르게 접근할 수 있습니다. - O(1) 중간 삽입/삭제는 느립니다. - O(N) 2️⃣ List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); 의미 인터페이스 타입으로 선언, 구현체로 생성 선언 타입 : List (인터페이스) 실제 객체 : ArrayList (구현체) 장점 나중에 구현체를 쉽게 바꿀 수 있습니다. List&lt;Integer&gt; list = new LinkedList&lt;&gt;(); 코드의 유연성(확장성) 증가 : 코드가 인터페이스에만 의존하면, 구현체가 바뀌어도 메서드 변경이 없습니다. 좋은 설계 원칙 : 상위 타입(List)으로 참조 → 구현체 숨김 → OCP(Open-Closed Principle) 3️⃣ ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); 의미 구현체로 선언, 구현체로 생성 선언 타입 : ArrayList (구현체) 실제 객체 : ArrayList 특징 ArrayList에만 있는 특화 메서드를 사용할 수 있습니다. 그러나 대부분의 경우 ArrayList만의 특화 기능은 거의 없습니다. 따라서 불필요하게 구현체에 종속적이 됩니다. 4️⃣ 차이점 : 다형성(polymorphism) 선언 방식 다형성 구현체 교체 유연성 List list = new ArrayList&lt;&gt;(); O O 유연 ArrayList list = new ArrayList&lt;&gt;(); X X 덜 유연 언제 ArrayList 타입으로 선언하나?특별한 이유가 없다면 인터페이스 타입(List)로 선언하는 것이 바람직합니다. 하지만 ArrayList의 고유 메서드를 써야 한다면 ArrayList로 선언해야 합니다. 예: trimToSize(), ensureCapacity()5️⃣ 전체 비교 정리 구분 List ArrayList 타입 인터페이스 클래스 (구현체) 역할 규약만 정의 List를 배열 기반으로 구현 구현체 교체 유연 어려움 " }, { "title": "[코딩테스트] Java 정리 - 2 (1)", "url": "/posts/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%9E%90%EB%B0%94-%EC%A0%95%EB%A6%AC2/", "categories": "Coding Test, Study", "tags": "java", "date": "2025-07-21 02:30:00 +0900", "snippet": "코딩테스트에서 자주 사용되는 Java 자료구조 등을 정리했습니다. 컬렉션 프레임워크는 다양한 자료구조를 직접 구현하지 않고, 쉽게 사용할 수 있도록 제공해줍니다.A. 기초1. 배열 (Array)동일한 타입의 데이터를 연속적으로 저장하는 고정된 크기의 자료구조입니다. 새로운 데이터 삽입/삭제는 불가능하고, 값을 변경하는 것은 가능합니다. 인덱스를 이용해 요소에 접근 및 변경하는 것의 시간 복잡도는 O(1)입니다. 연속된 메모리의 공간으로 메모리 관리가 효율적입니다. 선언 및 초기화 : int[] arr = new int[N]; int[] arr = {1, 2, 3}; 다차원 배열 : int[][] matrix = new int[N][M]; java.util.Arrays 클래스 : 배열 관련 유용한 메서드 제공 Arrays.sort(arr) : 배열 정렬 - (O(NlogN) : Dual-Pivot QuickSort / Tim-Sort) Arrays.copyOf(arr, 복사할 길이) : 배열 복사 Arrays.copyOfRange(arr, 0, position) : 부분 배열 반환 Arrays.fill(arr, value) : 배열의 모든 요소를 특정 값으로 채우기 (int라면 기본 0) Arrays.toString(arr) : 배열 모든 요소 출력 arr.length : 배열의 길이 출력 arr.clone() : 배열 복사 Arrays.asList(arr) : 배열을 리스트로 변환 B. List 인터페이스순서 O / 중복 O2. ArrayList 클래스가변 크기의 배열이므로, 값을 삽입 혹은 삭제를 할 수 있습니다. 맨 뒤에 삽입하거나 삭제할 때는 평균 시간 복잡도가 O(1)이지만, 중간에 삭제나 삽입할 때는 O(N)까지 커질 수 있습니다. 인덱스를 통한 접근이 빠릅니다. (내부적으로 배열 기반) 선택 시 고려사항 임의 접근이라는 특징이 있어 인덱스로 바로 접근할 수 있으므로 데이터에 빈번하게 접근하는 경우 효율적 ex. 그래프를 표현할 때 간선 여부도 시간 복잡도 O(1)로 판단할 수 있습니다. 하지만 메모리 공간을 충분히 확보해야 함 할당할 수 있는 메모리 크기 확인 : 데이터가 너무 많으면 런타임에서 배열 할당에 실패할 수 있습니다. OS마다 다르지만 보통 정수형 1차원 배열은 1000만 개, 2차원 배열은 3000 * 3000 크기를 최대로 생각 중간 데이터 삽입이 많은지 확인 : 선형 자료구조이므로 중간/처음에 빈번하게 삽입하면 시간 복잡도가 높아져 시간 초과가 발생할 수 있습니다.기본 사용 예시import java.util.ArrayList;public class ListExample { public static void main(String[] args) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); // 인터페이스로 선언 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); // 클래스로 선언 list.add(10); // 요소 추가 list.add(20); list.add(30); list.add(idx, 40); // 원하는 위치에 추가 System.out.println(list.get(2)); // 인덱스로 값에 접근 (30) list.set(1, 100); // 해당 인덱스의 값 변경 list.remove(list.size() - 1); // 마지막 요소 삭제 (원하는 인덱스 데이터 삭제) list.remove(Integer.valueOf(100)); // 값이 100인 요소 삭제 (오버로딩 주의) System.out.println(list); // [10] for (int num : list) { // for-each문 System.out.println(num); } }}연관 메서드ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 4, 5, 3));System.out.println(list.size()); // 5System.out.println(list.isEmpty()); // falseCollections.sort(list); // 오름차순 정렬 [1, 2, 3, 4, 5]Collections.sort(list, Collections.reverseOrder()); // 내림차순 정렬list.contains(3); // 해당 값이 있는지 출력 truelist.indexOf(3); // 해당 값의 인덱스 반환list.addAll(list2); // list 뒤에 list2가 삽입Collections.addAll(list, arr); // 배열을 리스트로 변환Integer[] arr = list.toArray(new Integer[list.size()]); // 리스트를 배열로 변환 (원시형X, for문이 더 빠름)List&lt;Integer&gt; list3 = list.subList(1, 3); // 특정 범위의 데이터 List로 반환2차원 ArrayListArrayList&lt;ArrayList&lt;Integer&gt;&gt; matrix = new ArrayList&lt;&gt;();// 초기화 예시 (행 추가)for (int i = 0; i &lt; 3; i++) { matrix.add(new ArrayList&lt;&gt;());}// 값 추가matrix.get(0).add(1);matrix.get(0).add(2);matrix.get(1).add(3);matrix.get(1).add(4);matrix.get(2).add(5);matrix.get(2).add(6);// 출력for (ArrayList&lt;Integer&gt; row : matrix) { for (int val : row) { System.out.print(val + \" \"); } System.out.println();} (참고) LinkedList 클래스 양방향 연결 리스트로 삽입/삭제가 빈번한 경우 유리하지만, 인덱스 접근은 느림 (내부적으로 노드 기반) List&lt;Integer&gt; list = new LinkedList&lt;&gt;(); 거의 사용하지 않음, Deque도 ArrayDeque 추천 구분 ArrayList LinkedList 내부 구조 동적 배열 (배열 기반) 이중 연결 리스트 인덱스 접근 매우 빠름 O(1) 느림 O(N) 중간 삽입/삭제 느림 O(N) 빠름 O(1) 끝 삽입 평균 O(1) (가끔 O(N) 배열 재할당 발생) 빠름 O(1) 추가 메모리 없음 노드마다 포인터 필요 사용 예 검색, 랜덤 접근 삽입/삭제 많을 때, Deque (참고) Stack 클래스 후입선출 LIFO(Last-In-First-Out) 자료구조 Vector를 상속하기 때문에 문제점이 많아 잘 안쓰임 (대신 ArrayDeque 사용) Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();stack.push(30);stack.push(50);System.out.println(stack.peek()); // 50System.out.println(stack.isEmpty()); // falseSystem.out.println(stack.size()); // 2stack.pop(); // 50stack.pop(); // 30 C. Queue 인터페이스FIFO (First-In, First-Out) 구조연관 메서드 메서드 설명 boolean add(Object o) 객체를 Queue에 추가, 저장공간 부족 시 IllegalStateException 발생 Object remove() Queue에서 객체를 꺼내 반환, 비어있을 경우 NoSuchElementException 발생 Object element() 삭제없이 요소 반환, 비어있을 경우 NosuchElementException 발생 boolean offer(Object o) Queue에 객체 저장, 가득 차 있다면 false 반환 (예외 없음) Object poll() Queue에서 객체 꺼내서 반환 (기본적으로 가장 작은), 비어있을 경우 null을 반환 Object peek() 삭제없이 요소 반환, 비어있을 경우 null을 반환 시간 복잡도 자료구조 삽입/삭제 시간 복잡도 비고 LinkedList O(1) 앞뒤 삽입/삭제 모두 빠름 ArrayDeque Amortized O(1) 내부 배열을 재할당할 수 있음 PriorityQueue O(log n) 힙 구조로 우선순위 유지 필요 일반 큐 : ArrayDeque (빠르고 효율적) 우선순위 큐 : PriorityQueue 삽입/삭제가 많거나 리스트 기능도 필요 : LinkedList Deque 인터페이스 Deque(Double-Ended Queue)는 양쪽 모두 삽입/삭제가 자료구조입니다. 스택으로 사용할 수도 있고, 큐로 사용할 수도 있습니다. Deque의 조상은 Queue이며, 구현체로 ArrayDeque와 LinkedList가 있습니다. 동작 앞에서 뒤에서 삽입 addFirst(e), offerFirst(e) addLast(e), offerLast(e) 제거 removeFirst(), pollFirst() removeLast(), pollLast() 조회 getFirst(), peekFirst() getLast(), peekLast() 3. PriorityQueue 클래스일반적인 큐와는 조금 다르게, 원소에 우선 순위(priority)를 부여하여 우선 순위가 높은 순으로 정렬되고 꺼냅니다. 기본 자료형의 경우 Comparable이 이미 존재하나, 사용자 정의 클래스일 경우 필수적으로 Comparable 인터페이스 또는 Comparator를 구현해야 합니다. compareTo() 메서드 로직에 따라 자료 객체의 우선순위를 결정하는 식으로 동작되기 때문입니다. 내부적으로 힙(Heap) 구조를 사용하고, null 요소를 허용하지 않습니다.선택 시 고려사항 가장 작은/큰 값을 빠르게 꺼내야 할 때 적합 (예: 다익스트라 알고리즘) Comparable 구현이 없다면 정렬된 순서로 저장되지는 않음 → 반복 순회 시 정렬 순서 X기본 사용 예시 (기본 자료형 사용)PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;();Queue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;();pq.offer(5);pq.offer(1);pq.offer(3);System.out.println(pq.poll()); // 1 (가장 작은 값 + 삭제)System.out.println(pq.peek()); // 3 (가장 작은 값)Comparable 구현 (사용자 정의 클래스 사용)class Student implements Comparable&lt;Student&gt; { String name; int priority; // 우선순위 값 public Student(String name, int priority) { this.name = name; this.priority = priority; } @Override public int compareTo(Student u) { // Student의 priority값을 비교해 우선순위를 결정하여 정렬 if (this.priority &lt; u.priority) { return -1; } else if (this.priority == u.priority) { return 0; } else { return 1; } } // 출력 오버라이드 (구현 안하면 필드 직접 출력 해야 함 ex. s.name); @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + \", priority=\" + priority + '}'; }}public static void main(String[] args) { // 오름차순 우선순위 큐 Queue&lt;Student&gt; pq = new PriorityQueue&lt;&gt;(); pq.offer(new Student(\"주몽\", 5)); pq.offer(new Student(\"세종\", 9)); pq.offer(new Student(\"홍길동\", 1)); pq.offer(new Student(\"임꺽정\", 2)); // 우선순위 대로 정렬됨 System.out.println(pq); // 우선순위가 가장 높은 값 참조 System.out.println(pq.peek()); // Student{name='홍길동', priority=1} // 차례대로 꺼내기 System.out.println(pq.poll()); // Student{name='홍길동', priority=1} System.out.println(pq.poll()); // Student{name='임꺽정', priority=2} System.out.println(pq.poll()); // Student{name='주몽', priority=5} System.out.println(pq.poll()); // Student{name='세종', priority=9}}Comparator 전달 (사용자 정의 클래스 사용)class Task { int priority; public Task(int p) { this.priority = p; }}PriorityQueue&lt;Task&gt; pq = new PriorityQueue&lt;&gt;(Comparator.comparingInt(t -&gt; t.priority));pq.offer(new Task(1));pq.offer(new Task(3));System.out.println(pq.poll().priority); // 14. ArrayDeque 클래스ArrayList와 유사하지만 배열 기반의 양방향 덱(Deque) 구현체입니다. Stack 클래스와 대기열로 사용할 때의 LinkedList보다 빠르게 사용 가능합니다. 사이즈에 제한이 없고, null 요소는 저장되지 않습니다.선택 시 고려사항 스택 또는 큐를 빠르게 구현하고 싶을 때 가장 효율적 LinkedList보다 빠른 퍼포먼스를 제공기본 사용 예시Deque&lt;Integer&gt; dq = new ArrayDeque&lt;&gt;();dq.offerLast(100); // [100]dq.offerFirst(10); // [10, 100]dq.offerFirst(20); // [20, 10, 100]dq.offerLast(30); // [20, 10, 100, 30]dq.pollFirst(); // 20 &lt;- [10, 100, 30]dq.pollLast(); // [10, 100] -&gt; 30dq.pollFirst(); // 10 &lt;- [100]dq.pollLast(); // [] -&gt; 1005. LinkedList 클래스List, Deque, Queue 인터페이스 모두를 상속받고 있으므로, 다양한 자료구조로 응용이 가능합니다. 양방향 연결 리스트로 구성되어 있고, null 요소를 허용합니다.선택 시 고려사항 중간 삽입/삭제가 많은 경우 유리 성능은 단순한 Queue에 비해 느릴 수 있음기본 사용 예시Queue&lt;String&gt; q = new LinkedList&lt;&gt;(); // Queue 타입으로 받음Deque&lt;String&gt; q = new LinkedList&lt;&gt;(); // Deque 타입으로 받음q.offer(\"A\");q.offer(\"B\");q.offer(\"C\");System.out.println(q.poll()); // \"A\"System.out.println(q); // [B, C] 참고 블로그 Inpa Dev - Collections Framework 총정리 " }, { "title": "[코딩테스트] Java 정리 - 1", "url": "/posts/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%9E%90%EB%B0%94-%EC%A0%95%EB%A6%AC1/", "categories": "Coding Test, Study", "tags": "java", "date": "2025-07-20 02:30:00 +0900", "snippet": "코딩테스트에서 자주 사용되는 Java 문법들을 정리했습니다.1. 자료형 (Data Types) 기본 자료형 (Primitive Types) 자료형 설명 크기 값의 범위 int 정수 4 byte (32비트) -2,147,483,648 ~ 2,147,483,647 (-2^31 ~ 2^31-1) long 정수 (큰 범위) 8 byte (64비트) -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 (-2^63 ~ 2^63-1) double 실수 (부동소수점) 8 byte (64비트) ±(4.9 × 10^-324 ~ 1.8 × 10^308), 소수점 약 15~16자리 정밀도 boolean 논리값 JVM마다 다르지만 보통 1 byte true / false char 단일 문자 (Unicode) 2 byte (16비트) 0 ~ 65,535 (\\u0000 ~ \\uFFFF) 참조 자료형 (Reference Types) String: 문자열 객체 Integer, Long 등 래퍼 클래스 (Wrapper Classes): 기본 자료형을 객체 형태로 다룰 때 사용 (ex. 컬렉션에 저장) 사용자 정의 클래스, 배열 등 모든 객체는 참조 자료형 2. 형 변환 (Type Conversion) String → int / charString str = \"123\";int intVal = Integer.parseInt(str); // Integer 반환int intVal = Integer.valueOf(str).intValue(); // int 반환String str = \"string\";char c = str.charAt(0); // 특정 인덱스의 문자를 char로 반환 (s)char[] cArr = str.toCharArray(); // 문자열을 char형 배열로 반환 int → double / String / charint i = 123;double d = i; // 자동 형변환int intVal = 123;String str = Integer.toString(intVal);String str = String.valueOf(intVal);String str = intVal + \"\";int a = 65;char b = (char) a; // 아스키 코드 값에 상응하는 char 반환 - 강제 형 변환 (A)int a ='1'; // 0-9 사이의 값을 ‘’사이에 넣어주면 문자 그대로의 char 반환, (1 + '')도 가능char b = (char) a; // (1)int a = 123456789;char b = Integer.toString(a).charAt(3); // 문자열로 변환 후 char 반환 (4)int a = 12;char b = Character.forDigit(a , 16); // a를 16진법으로 변환 (c) char → int / Stringchar a = ‘1’;int b = a; // 더 큰 자료형에 작은 자료형을 할당하면 더 자동 형변환 (아스키 49)int b = (int) a; // 강제 형변환 (아스키 49)int b = Character.getNumericValue(a); // 아스키 아닌 정수 자체의 값 반환 (1)char a = 'A'int b = a - '0' // ‘A’의 10진수 97에 ‘0’의 10진수 80을 뺀 17 반환char a = 'c'; // char[] a = {'a','b','c','d','e'}; 배열 넣으면 abcde 반환String b = Character.toString(a);String b = String.valueOf(a);String b = a + \"\";3. 빠른 입출력 (Fast I/O)일반적인 Scanner나 System.out.println은 대규모 입력/출력 시 시간 초과될 수 있습니다. BufferedReader와 BufferedWriter를 사용하는 것이 좋습니다.import java.io.*;import java.util.StringTokenizer; // 문자열 파싱 시 유용public class Main { public static void main(String[] args) throws IOException { // IOException 처리 필수 BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); // 1. 한 줄 읽기 String line = br.readLine(); // 2. 공백 기준 여러 개 입력 (숫자로 변환 시 Integer.parseInt() 사용) StringTokenizer st = new StringTokenizer(br.readLine()); int a = Integer.parseInt(st.nextToken()); int b = Integer.parseInt(st.nextToken()); // 또는 split() 메서드 사용 (정규식 기반으로 유연하지만 StringTokenizer보다 느릴 수 있음) String[] parts = line.split(\" \"); int num1 = Integer.parseInt(parts[0]); // 2차원 배열 입력 (예: n x n 행렬) int n = Integer.parseInt(br.readLine()); int[][] map = new int[n][n]; for (int i = 0; i &lt; n; i++) { st = new StringTokenizer(br.readLine()); for (int j = 0; j &lt; n; j++) { map[i][j] = Integer.parseInt(st.nextToken()); } } // 3. 출력 (문자열로 변환하여 출력) bw.write(String.valueOf(a + b)); // int -&gt; String bw.newLine(); // 개행 문자 추가 bw.write(\"Sum: \" + (a + b) + \"\\n\"); bw.flush(); // 버퍼 비우기 (필수) br.close(); // 스트림 닫기 bw.close(); // 스트림 닫기 }}4. String 조작String은 불변(immutable) 객체입니다. str.length() : 문자열 길이 str.charAt(index) : 특정 인덱스의 문자 str.substring(beginIndex) / str.substring(beginIndex, endIndex) : 부분 문자열 추출 str.equals(otherStr) : 문자열 내용 비교 (==는 주소 비교) str.indexOf(char/string) : 특정 문자/문자열의 첫 번째 인덱스 str.replaceAll(regex, replacement) : 특정 패턴을 다른 문자열로 치환 str.split(regex) : 특정 구분자를 기준으로 문자열 분리하여 String[] 반환String s = \"Hello World\";char c = s.charAt(0); // 'H'String sub = s.substring(0, 5); // \"Hello\"boolean same = \"abc\".equals(\"abc\"); // true5. StringBuilder문자열을 효율적으로 변경(추가, 삽입, 삭제 등)해야 할 때 사용합니다. StringBuilder는 가변(mutable) 객체로, String 조작보다 성능이 좋습니다. (String은 불변 객체라서, + 연산할 때마다 새로운 문자열 객체가 만들어짐 → 비효율적) (StringBuilder는 내부에서 가변 배열을 사용해서 성능이 훨씬 좋음) StringBuilder sb = new StringBuilder(); sb.append(value): 문자열 추가 sb.insert(idx, str): 특정 위치에 삽입 sb.delete(start, end): 특정 범위 삭제 (start 이상, end 미만) sb.setCharAt(idx, ch): 특정 위치 문자 변경 sb.reverse(): 문자열 뒤집기 sb.toString(): StringBuilder를 String으로 최종 반환 sb.CharAt(idx): 특정 위치 문자 반환 sb.length(): 문자열 길이 반환// 기본 사용법StringBuilder sb = new StringBuilder();sb.append(\"Hello\");sb.append(\" \");sb.append(\"World\");System.out.println(sb.toString()); // Hello World// 반복문에서 문자열 붙일 때StringBuilder sb = new StringBuilder();for (int i = 1; i &lt;= 5; i++) { sb.append(i).append(\" \");}System.out.println(sb); // 1 2 3 4 5// 마지막 공백 제거if (sb.length() &gt; 0) { sb.setLength(sb.length() - 1); // 마지막 문자 제거 (공백 등)}" }, { "title": "[코딩테스트] Java 정리 - 0", "url": "/posts/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%9E%90%EB%B0%94-%EC%A0%95%EB%A6%AC0/", "categories": "Coding Test, Study", "tags": "java", "date": "2025-07-19 02:30:00 +0900", "snippet": "코딩테스트에서 가장 중요한 시간 복잡도 별 알고리즘을 정리했습니다.1. 시간 복잡도 대부분의 코딩테스트 환경은 1초에 약 1억 번(10⁸) 연산을 처리할 수 있다고 가정합니다. (자바는 C++보다 살짝 느려서, 5천만~7천만 연산 정도로 안전하게 계산) 따라서 대략 1억 번 이하의 연산은 1초 안에 돌아간다고 봅니다. 1초 ≈ 1억 번 연산 → 자바에선 안전하게 5천만 번으로 잡기! N이 작으면 완탐 N이 크면 정렬/이분탐색/DP 100만 넘어가면 무조건 O(N) 상수 계수 큰 연산 (문자열 처리, 객체 연산 등) 주의 PriorityQueue 많이 쓰면 힙 O(N log N) ArrayDeque로 Stack/Queue 대체 제한 시간 최대 N (자바) 권장 복잡도 대표 알고리즘 예시 설명 0.5 ~ 1초 10 이하 O(N!), O(2^N) 순열, 조합, 백트래킹 완전탐색, 부분집합 전수조사 1초 500 이하 O(N³) 플로이드-워셜, 3중 for DP 내부 연산이 단순할 때만 가능 1초 1,000 이하 O(N²) ~ O(N³) DP 테이블, 인접행렬 BFS N²는 안전, N³은 구조에 따라 가능 1초 10,000 이하 O(N²) 이중 루프, 단순 DP, 간단 그리디   1초 100,000 이하 O(N log N) 정렬, 힙, 우선순위 큐, 세그먼트 트리, 이분 탐색   1초 1,000,000 이하 O(N) 투포인터, 누적합, 해시맵   1초 10⁷ 이상 O(1), O(log N) 수식 계산, 단일 이분 탐색   2 ~ 3초 +1 ~ 2배 그래프 탐색(BFS/DFS), 큰 DP 대용량 입력 제한 완화   5초 이상 더 큰 N 최적화 필요 대형 그래프, 느린 완전탐색   (참고) N이 1,000일 때, O(N³)..? O(N³)은 플로이드-워셜 수준만 괜찮음 (단순 연산) O(N³)이라도 N이 2,000이면 거의 불가능 O(N²)도 10,000 넘으면 느려짐 → N log N 알고리즘으로 바꿔야 안전 2. 알고리즘 및 시간복잡도 복잡도 대표 알고리즘 O(1) 수식 계산, 간단한 값 비교 O(log N) 이분탐색, lower_bound, upper_bound O(N) 선형 탐색, 단일 루프, 투포인터, 누적합 O(N log N) 정렬(퀵 평균, 머지, 힙), 우선순위 큐 O(N²) 이중 for문, 인접행렬 그래프, 정렬(퀵 최악, 버블, 선택) O(N³) 플로이드-워셜 O(2ⁿ) 순열, 부분집합 O(N!) 모든 경우의 수 완전탐색 3. log 계산 밑이 2와 10은 약 3배 정도 차이남, 그러나 빅오에서 상수배는 무시되므로 영향 없음 N log₂(N) log₁₀(N) 10 3.3 1 100 6.6 2 1,024 (2¹⁰) 10   1,000 ≈ 2¹⁰ 약 10 3 1,000,000 ≈ 2²⁰ 약 20 6 1,000,000,000 ≈ 2³⁰ 약 30 9 밑 의미 예시 2 반으로 쪼갬 이분탐색, 트리 높이 10 자리수 계산 자릿수, 문자열 처리 e 자연로그 거의 안 씀 (수학용) 4. 문제 예시 문제 예시 N 권장 알고리즘 모든 순열 8 O(N!) 플로이드-워셜 500 O(N³) DP (배낭 문제) 1,000 O(N²) 배열 정렬 100,000 O(N log N) 큰 수에서 부분합 1,000,000 O(N) 소수 판별 10⁹ O(√N) 이분 탐색 10⁹ O(log N) 참고 블로그 시간 복잡도, 공간 복잡도, 빅오 이해하기 " }, { "title": "블로그 시작 🙋‍♀️", "url": "/posts/%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%8B%9C%EC%9E%91/", "categories": "etc, Blog", "tags": "blog", "date": "2022-07-28 02:30:00 +0900", "snippet": "블로그를 만들겠다고 생각하고 실행에 옮기기까지 적지 않은 시간이 걸렸다.이제서야 첫 게시글을 작성한다😅Hello, World!많은 플랫폼이 있었지만, GitHub를 선택하게 된 이유는…git의 사용법을 더 빨리 익히고 싶었기 때문이다.그러나 시작하면서 아주 살짝 후회되었다.익숙지 않은 탓에 Repository를 몇 번이나 지우고 다시 만들었는지 모를 정도로 여러 시행착오를 거치면서 마지막이라 생각하고 시도했을 때, 블로그가 생성된 것을 보자마자 내적 소리를 질렀다.과장해서 말하자면, 22년 인생 중 가장 큰 성취감을 느낀 순간 Top 5안에 들 것이다…하고 싶은 것을 찾은 지는 얼마 안 되었지만,앞으로의 성장을 위해 지금까지 공부한 작은 지식과 앞으로 배울 것들을 기록해 나갈 예정이다.🏃‍♀️" } ]
